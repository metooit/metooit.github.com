<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[K.I.S.S]]></title>
  <link href="http://metooit.github.com/atom.xml" rel="self"/>
  <link href="http://metooit.github.com/"/>
  <updated>2013-03-15T17:32:37+08:00</updated>
  <id>http://metooit.github.com/</id>
  <author>
    <name><![CDATA[metooit]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[For You And For Me]]></title>
    <link href="http://metooit.github.com/blog/2013/03/15/for-you-and-for-me/"/>
    <updated>2013-03-15T16:49:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/03/15/for-you-and-for-me</id>
    <content type="html"><![CDATA[<p>学习编程对于我来说就是一种生活，但是我所期待的另一种生活是能够用编程来改变人们的生活！</p>

<p>这算是我的一个宏愿吧，但是我还是一直为此而努力着。因为不是有一句话叫做不想当将军的士兵不是好士兵吗？我想对于一个程序员来讲，不想去实现这样一个愿望便枉自为程序员吧！</p>

<p>看到一个关于编程的公益广告<a href="http://video.sina.com.cn/v/b/98166519-2036021381.html">视频地址</a>,里面有好多我所崇拜的大牛，看完视频感觉到他们是计算机世界里的英雄，也是我们生活中的英雄，因为他们正是那些用编程来改变人们生活的人！</p>

<p>虽然是一个小菜程序员，但是我还是因为自己当时选择编程这条道路感到庆幸，因为是编程让我真正爱上了生活！以前的我以为自己喜欢的是电子行业，因为我看到电子产品以惊人的速度进入并改变着人们的生活。所以大学我选择了电子信息工程专业，但是我的兴趣却逐渐转向了编程领域，最初的C语言实现一个小程序实现输出“Hello World！”的时候，我觉得兴奋异常，怎么说呢？这样一种兴奋来自一种成就感或者说来自一种探索欲，我开始觉得自己能够操纵机器去做一些事情，那个说的酸溜溜一点就是一点小幸福吧！o(∩∩)o&#8230;哈哈，总之我就是这样不可救药的喜欢上了编程！</p>

<p>为什么我对编程这么着迷吗？我想对你说：学习编程吧，哪怕你只是想多了解一点计算机，然后你就会懂我了，这是一个可以作为爱好的事情！</p>

<p>这篇文章，For you and for me， enjoy Programming, enjoy Life!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[不得不面对的一切]]></title>
    <link href="http://metooit.github.com/blog/2013/03/14/something-you-have-to-face/"/>
    <updated>2013-03-14T06:41:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/03/14/something-you-have-to-face</id>
    <content type="html"><![CDATA[<p>今天听说了一个算是很不好的消息， 我的一个好朋友要退学了， 这让我忽然间感觉到世事无常， 如此让人伤感， 有些事情， 放下要比接受起来更难……</p>

<p>如果这个传闻是真的， 那我对中国的教育体制感到失望， 为我的同学感到可惜， 同时有些事情也值得我们去深思……</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git —— 如何让我不爱你]]></title>
    <link href="http://metooit.github.com/blog/2013/03/11/what-are-you-doing/"/>
    <updated>2013-03-11T18:54:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/03/11/what-are-you-doing</id>
    <content type="html"><![CDATA[<p>要想要知道一个朋友如何， 那你就应该多去了解他， 如果想要知道Git如何， 那么多多地去接触它， 深入的去了解它吧！ Git是美丽由内而外的美。</p>

<p>上一篇《Git 工作流程》还没有写完， 时隔几天， 我还要把没有总结学习过得步骤继续完善在这里：</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Follow the professional way]]></title>
    <link href="http://metooit.github.com/blog/2013/03/08/follow-the-professional-way/"/>
    <updated>2013-03-08T23:14:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/03/08/follow-the-professional-way</id>
    <content type="html"><![CDATA[<p>这两天一直在跟着两个Dinael的脚步实现<code>game-of-life</code>， 从中我学到了很多东西， 我最感激两位Dinael的一点是： 你们让我看到了<code>Pair Programming</code>的好处， 最重要的是你们让我看到了专业的程序员的工作流程， 也让我学到了一些思考、编码、测试的方法， 真的是很感谢你们！</p>

<p>记得假期的时候看了一个台湾程序员的博客， 其中写到： 如果你打算从事这个行业， 那你就不能是业余地去学习， 而是要把它当成自己的专业去努力去钻研！（大体是这个意思） 作者写到自己在工作的前几年去了一个和自己喜欢的编程工作关系不大的公司， 怀着自己利用业余时间去学习编程的想法， 作者的工作生活并不开心， 然后他开始思考并毅然绝然的辞去了工作， 选择了做一个<code>Ruby</code>程序员， 然后现在的他成功了！</p>

<p>所以， 我在心里不断告诉自己： 你要知道自己想要什么， 想成为一个怎样的人， 想要朝着怎样的目标努力。 有时候我会怪自己， 觉得自己不够有主见， 所以我也会一直告诉自己， 做自己吧！不要在乎其他人的想法， 不要在意别人的眼光！ 其实呢， 除了最亲的人和最好的朋友， 其他人又在意你的什么呢？ 就像我的语文老师曾经给我们看得一首诗一样： 注定， 每个人都是过客。 梦想是注定孤独的旅程， 让支持我的与嘲笑我的人都看到最真实的我， 无论如何， 我始终在走着自己的路， 谢谢你们的陪伴或擦肩而过， 让我体会到这真真实实的人生。</p>

<p>记得小时候的我总会想自己以后会做什么， 现在的我最想时刻提醒自己的却是： 你要明白你现在在干什么。 至于将来， 相信那句话吧： 天道酬勤！ 总是在内心里告诉自己， 你还差得很远， 你还不行…… 但是， 为什么不告诉自己： 你很好， 坚持下去， 也许你还不够好， 但只要你够勤奋……</p>

<p>我的未来取决与我的现在</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git 工作流程]]></title>
    <link href="http://metooit.github.com/blog/2013/03/07/git-work-flow/"/>
    <updated>2013-03-07T11:46:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/03/07/git-work-flow</id>
    <content type="html"><![CDATA[<p>Git是我最常用的版本控制工具， 当然也是我喜欢的工具之一， 我想要写一篇系统的文章来总结一下我在平时使用中总是要用到的一些<code>Git</code>的命令和技巧等， 来记录使用<code>Git</code>工作的流程。</p>

<hr />

<h2>Why Git?</h2>

<p><code>Git</code>的起源和开源运动的进行颇有渊源， 它就诞生于<code>Linux</code>兴起的那个伟大的时代， <code>Git</code>的出现正是<code>黑客精神</code>的体现， 代表了黑客们对于自由分享的向往和不懈地执着地努力！</p>

<blockquote><p>Git起源：
Linux内核最初的维护工作都是提交补丁和保存归档， 但是从2002年开始使用分布式版本管理系统<code>BitKeeper</code>来管理， 但是后者于2005年收回了Linux开源社区免费使用的权利， 于是， 为了避免重蹈复辙， Linus Torvalds 决定开发一套开源的版本控制系统， 然后Git就此诞生了， 不得不佩服这样一群黑客的伟大创举， 再次向他们致敬！</p></blockquote>

<h3>Git 的原则：</h3>

<p>说到Git的原则， 我不禁想到了<code>Unix</code>的原则， 可以说它们在某些方面是一脉相乘的：
* 简洁
* 速度
* 分布式
* 并发支持</p>

<h3>Git 很方便：</h3>

<ul>
<li>直接记录快照， 而不关心具体的数据变化</li>
<li>近乎所有的操作都在本地执行</li>
<li>时刻保持数据完整性</li>
<li>多数操作仅仅是添加数据</li>
</ul>


<p>Git 有如此多的Sexy的特性， 让人怎么能够不喜欢呢？ 正是因为有了这些特性， Git让版本控制变得不再让人头疼。</p>

<hr />

<h2>How To Install Git?</h2>

<p>在<code>Linux</code>系统上的安装很简单：只要调用系统默认的软件包管理器使用命令安装就好了
比如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ubuntu系统：
</span><span class='line'>> sudo apt-get install git
</span><span class='line'>fedora系统：
</span><span class='line'>> sudo yum install git</span></code></pre></td></tr></table></div></figure>


<h2>And The Configuration?</h2>

<p>Git 的配置文件可以分为三个层级：
* /etc/gitconfig 中所配置的是系统中所有用户的通用配置。
如果使用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>> git config --system</span></code></pre></td></tr></table></div></figure>


<p>修改的就是这个文件了</p>

<ul>
<li>~/gitconfig 中所做的配置只是针对当前的用户
如果使用：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>> git config --global</span></code></pre></td></tr></table></div></figure>


<p>修改的就是这个文件了</p>

<ul>
<li>最后一级就是当前项目中<code>.git</code>文件夹下的<code>config</code>配置文件了， 这个配置仅对当前项目有效。</li>
</ul>


<p>所以， 安装<code>Git</code>完成后， 就需要对<code>Git</code>进行配置了：</p>

<h3>用户信息：</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git config --global user.name "xxxx"
</span><span class='line'>$ git config --global user.email "xxxx@xxxx.xxx"</span></code></pre></td></tr></table></div></figure>


<h3>文本编辑器：</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git config --global core.editor vi</span></code></pre></td></tr></table></div></figure>


<p>当然是选择我最喜欢的<code>Vim</code>啦！～</p>

<h3>差异分析工具：</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git config --global merge.tool vimdiff</span></code></pre></td></tr></table></div></figure>


<h3>查看当前的配置信息：</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git config --list</span></code></pre></td></tr></table></div></figure>


<hr />

<!-- more -->


<h2>To Start Work With Git</h2>

<hr />

<h3>新建Project并开始使用Git管理：</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1. 创建工作目录:
</span><span class='line'>$ mkdir `工作目录名称`
</span><span class='line'>
</span><span class='line'>2. 切换到工作目录：
</span><span class='line'>$ cd `工作目录名称`
</span><span class='line'>
</span><span class='line'>3. 初始化工作目录：（Git初始化）
</span><span class='line'>$ git init</span></code></pre></td></tr></table></div></figure>


<p>这几步就可以新建一个工程， 并初始化使用<code>Git</code>管理了。执行完<code>git init</code>后工作目录下多了一个<code>.git</code>文件夹， 其中包含了各种设置信息等。<code>git init</code> 文件同时也执行了 <code>git add .</code> 这样的话， 如果你的目录中之前有文件的话， 那么执行这样的一条命令之后， 当前目录的文件会自动加入工程之中。</p>

<h3>添加文件纳入Git版本控制：</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1. 创建文件： （多种方式）
</span><span class='line'>$ touch `文件名称`
</span><span class='line'>
</span><span class='line'>2. 添加文件： （多种方式）
</span><span class='line'>$ git add `文件名称`
</span><span class='line'>
</span><span class='line'>3. Commit:
</span><span class='line'>$ git commit -m `INFORMARION`</span></code></pre></td></tr></table></div></figure>


<p>通常， 添加文件时我会使用<code>git add .</code>, 当然这也分情况而定。</p>

<blockquote><p>注：这里通常要新建一个<code>README.md</code>文件， 以让其他人了解你的项目， 同时也记录一些自己的项目进展和bug status等等.</p>

<pre><code>  另外， 可能需要一个`.gitignore`来忽略某些文件.
</code></pre></blockquote>

<h3>克隆现有项目：</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git clone #url# [自定义名称]</span></code></pre></td></tr></table></div></figure>


<hr />

<h2>Convenience With Git</h2>

<h3>查看当前文件状态：</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git status</span></code></pre></td></tr></table></div></figure>


<p>这条命令太常用了， 你可以时刻通过这样一条简单的命令掌控每一个文件的状态， 真心方便已极。</p>

<h3>暂存更新：</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git add [修改后的文件]</span></code></pre></td></tr></table></div></figure>


<h3>查看具体的修改状况：</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1. 查看未暂存的文件更新了那些部分：
</span><span class='line'>$ git diff
</span><span class='line'>
</span><span class='line'>2. 查看已暂存文件和上次提交的快照的差异：
</span><span class='line'>$ git diff --cached [--staged]</span></code></pre></td></tr></table></div></figure>


<hr />

<h2>The Exciting Time</h2>

<h3>提交更改：</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1. 提交准备：
</span><span class='line'>$ git status
</span><span class='line'>
</span><span class='line'>2. 提交更改：
</span><span class='line'>$ git commit</span></code></pre></td></tr></table></div></figure>


<p>注意： 每次提交之前要运行一下<code>git status</code>, 看看是否已经暂存， 这是一个好习惯。</p>

<p>另外， 提交时也可以包含一些信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git commit -m "提交信息（如Bug修正等）"</span></code></pre></td></tr></table></div></figure>


<p>提交的记录只是放在暂存区的快照， 每次提交之后， 你还可以通过快照回溯到以前的状态。 多牛啊！</p>

<h3>更快捷的提交：</h3>

<p>Git 提供了一个命令选项用来简化提交操作， 这个命令选项简化了<code>git add</code>这一步：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git commit -a</span></code></pre></td></tr></table></div></figure>


<p>对了！ 就是这个<code>-a</code>选项， 同时你也可以使用<code>-m</code>添加消息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git commit -am "提交信息"</span></code></pre></td></tr></table></div></figure>


<h3>移除文件：</h3>

<p>要移除某个文件， 必须从已经暂存的文件中将文件去除：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git rm [移除的文件名称]</span></code></pre></td></tr></table></div></figure>


<p>如果删除之前修改过， 并且已经放到暂存区域的话， 那么要使用强制删除选项： <code>-f</code></p>

<p>如果要将文件从Git仓库删除（暂存区域删除）， 但是仍保留在当前目录中， 即： 去除跟踪但是不删除文件， 一边在<code>.gitignore</code>中补上： <code>--cached</code></p>

<h3>移动文件：</h3>

<p>Git 并不跟踪文件的移动操作， 但是它可以判断出发生了什么：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git mv [源文件名] [目标文件名]</span></code></pre></td></tr></table></div></figure>


<p>实际上， 运行<code>git mv</code>相当与运行三个命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ mv [源文件名] [目标文件名]
</span><span class='line'>$ git rm [源文件名]
</span><span class='line'>$ git add [目标文件名]</span></code></pre></td></tr></table></div></figure>


<h3>查看提交历史：</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git log</span></code></pre></td></tr></table></div></figure>


<p>不带参数时， 会按时间列出所有的更新。</p>

<blockquote><p><code>-p</code> 选项展开显示每次提交的差异
<code>-数字</code> 选项选择最近的N次更新
<code>--stat</code> 选项仅显示简要的增改行数统计
<code>--pretty</code>
<code>--oneline</code> 或 <code>--pretty</code> 结合 <code>--graph</code>使用， 会显示ASCII 字符画</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The taste of time]]></title>
    <link href="http://metooit.github.com/blog/2013/03/07/the-taste-of-time/"/>
    <updated>2013-03-07T06:47:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/03/07/the-taste-of-time</id>
    <content type="html"><![CDATA[<p>昨天刷牙的时候， 忽然间觉得好像有某种似曾相识的感觉， 也说不清楚到底是什么样的感觉， 那更像是一种味道————时光的味道。</p>

<hr />

<p>“不管现在的处境如何， 到了回忆里， 一切都是甜美的” 当年读高三的时候看到这句话， 只觉得是一种勉励， 而今想起来却深觉其中味了， 再苦再难， 一切都会过去， 而回忆都是甜美的。</p>

<p>长久以来， 我始终觉得， 记忆中的事情， 很多都有自己独特的味道， 每一个我到过的地方也都要自己的味道， 总能在某一个瞬间， 我感觉到这种味道似曾相识， 让我不禁回忆起过去。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Interesting about bluetooth]]></title>
    <link href="http://metooit.github.com/blog/2013/03/06/interesting-about-bluetooth/"/>
    <updated>2013-03-06T19:17:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/03/06/interesting-about-bluetooth</id>
    <content type="html"><![CDATA[<p>今天上课时老师讲到了一个有趣的故事：蓝牙的来历。</p>

<p>很久很久以前（多俗啊……）， 古老的北欧有一个国王非常喜欢吃蓝莓， 所以国民进献了很多的蓝莓给他， 以至于他的牙齿都染成了蓝色了……（这是真的吗？） 然后就是有着么一个蓝牙齿的国王……</p>

<p>然后蓝牙的图标是怎么来的呢？参见<a href="http://en.wikipedia.org/wiki/Bluetooth">wikipedia</a></p>

<p>还有一篇关于这个有意思的小故事的<a href="http://news.xinhuanet.com/classad/2005-02/01/content_2534111.htm">新闻稿</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[For more education or For some practice]]></title>
    <link href="http://metooit.github.com/blog/2013/03/05/for-more-education-or-for-some-practice/"/>
    <updated>2013-03-05T21:13:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/03/05/for-more-education-or-for-some-practice</id>
    <content type="html"><![CDATA[<p>考研还是工作？</p>

<p>这是这个学期开始两天来同学们问得最多的一个问题， 对于这个问题， 我还时要问自己一句： 你真的想过了吗？</p>

<p>忽然间想起了之前看过的一片文章， 其中提到了人生的抉择与经济学， 这篇文章的作者就是已故的中国软件界倍受尊敬的<em>冯华军</em>, 我面临这样一个问题了现在， 然后自然想要再次温习一下， Google了好久居然找不到冯华军的博客了！！！ 唉， 可能是因为没有人打理博客， 域名因为欠费被注销了吧， 可惜……</p>

<p>我记忆犹深的有一部分是说， 有时候， 我们面临选择的时候可以试着用经济学中的某个理念（具体叫做什么有待考证）， 其方法就是： 试想我们已经作出了决定， 而且要试想好几次， 把每一种可能都要想到， 然后我们就去再深入的想， 假设每一种设想都得到最坏的结果， 最后我们比较最坏的这些结果， 看看这些最坏的结果中哪个是最好的， 那么这个结果就是要找的最优结果。</p>

<h2>具体分析：</h2>

<ul>
<li><p>如果选择考研：
考研可能遇到的状况就是准备了好久但是最后的结果却不尽如人意， 最坏的莫过于没有学校可上， 然后被迫去找工作， 然后没有找到理想的工作（还不至于流落街头吧， 我想……）。</p></li>
<li><p>如果选择工作：
找工作最坏的可能是找不到理想的工作， 从事了自己不喜欢的职业， 却因为生计所迫去做这份工作。</p></li>
</ul>


<p>这两种假设哪种是我可以接受的呢？ 那条路才是我该选择的呢？</p>

<h2>学会决定：</h2>

<p>记得以前读到过， 有人写道： 人生就是各种各样的选择。 面临如此多的选择， 我最应该做的是要学会决定， 做出自己的选择！ 而且， 我要给自己立一个规矩： 无论做出的选择结果如何， 都不要怨天尤人， 无悔无惧， 相信未来， 相信希望！</p>

<p>其实说到底， 考研还是工作都是自己的事情， 不要让别人的观点左右了自己的内心， 既然大多数的成功不能复制， 那么我又何必去追随别人的脚步然后不断祈祷能像xxx一样呢？ 安静下来吧， 让心安静一会儿， 然后倾听内心的声音， 这才是最重要的！</p>

<h2>选择选择：</h2>

<p>选择有时候确实是艰难的， 这个艰难包含了很多的层面， 很多的意思。 何去何从， 还是让我好好想一想吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hug Arch Linux]]></title>
    <link href="http://metooit.github.com/blog/2013/03/05/hug-arc-linux/"/>
    <updated>2013-03-05T20:30:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/03/05/hug-arc-linux</id>
    <content type="html"><![CDATA[<p>来到学校之后， 我觉得最终要的一件事情就是要配置好自己的机器， 然后开始一个学期的生活。 然后， 我想到了Arch， 事实上真正决定我一定要安装ArchLinux的就是它的理念：简洁。 因为这正是我想要的， Keep it simple, stupid! 这句话着实应该大声的喊出来。 选择ArcLinux也是要选择一种生活与工作的态度吧！</p>

<p>然后， 我就开始了我的ArchLinux之旅。</p>

<h2>第一步： 安装</h2>

<p>第一步当然是安装系统啦， <a href="https://wiki.archlinux.org/">Arch的文档</a> 真是全面而贴心啊， 我觉得写这些文档的人是真心可爱啊， 尤其是读到Arch的历史与目标的时候， 我忽然间觉得自己像是在做一件自己人生中的大事一样， 有些小小的激动了呢！</p>

<p><a href="https://wiki.archlinux.org/index.php/The_Arch_Way">The Arch Way</a> 写了Arch的哲学， 重点写了它的简洁，开放，自由等…… 如果想要理解和使用Arch， 这篇文章是一定要通读的。</p>

<p>我就从初学者手册开始吧！ <a href="https://wiki.archlinux.org/index.php/Beginners%27_Guide">Beginners Guide</a></p>

<p>因为我的台式机没有光驱， 所以最简单的方法莫过于U盘安装啦！ 然后， 我觉得这件事情再简单不过了， 所以没有往下看， 就没有按照初学者手册中所写去使用<code>dd</code>命令， 想到以前的经验， 觉得使用<code>UtralISO</code>再简单不过， 然后就莫名其妙的悲剧了， 我开机进入<code>BIOS</code>调整好启动顺序后， 虽然顺利的进入了Arch的欢
迎界面， 但是居然不能<code>Enter</code>进入安装过程， 本来我想就此问题Google之， 想到Arch的文档， 我决定还是要仔细读一下文档才好，果然， 在<a href="https://wiki.archlinux.org/index.php/Installation_Guide">Installation Guide</a> 中就有关于如何用U盘安装的部分， 真是汗颜啊！！！</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ dd if=&lt;path of Archlinux.iso> of=/dev/sdb bs=4M</span></code></pre></td></tr></table></div></figure>


<p>一条命令执行完后，重启， 真的是一下子就成功了， 都不知道Arch是怎么办到的， 居然这样都可以， 真的是很人性化的设计， 那么继续安装吧……
还有一件事情值得一题， 我本来以为<code>shell</code>会是大多数<code>Linux</code>发行版都安装的<code>Bash</code>呢， 没有想到是我最喜欢的<code>Zsh</code>， 这算是又一个意外的惊喜吧！ 而且这个zsh还是配置过一点的， 执行错了命令的时候会出现一个:-(  真是好玩， 嘻嘻。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The New Term Begin]]></title>
    <link href="http://metooit.github.com/blog/2013/03/04/the-new-term-begin/"/>
    <updated>2013-03-04T07:12:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/03/04/the-new-term-begin</id>
    <content type="html"><![CDATA[<p>新学期开始了， 本来想要昨天写这篇文章的， 可是昨天实在是太累了…… 今天早上起来终于有力气吐槽了……</p>

<p>@#$$%%<sup>^&amp;&amp;#$$%<sup>&amp;**$%$%!#@$$%%<sup>^&amp;……</sup></sup></sup></p>

<p>算了， 让昨天的一切都烟消云散吧， 今天是一个美好的开始。</p>

<h2>新学期的计划</h2>

<h3>关于学习</h3>

<ul>
<li>考不考研？ 这是我来了之后大家问起最多的问题， 这也是一个必须好好考虑的问题, 所以我计划的第一条就是要把这个问题好好考虑一下</li>
<li>如何学习？ 课上认真听讲吧， 然后就可以省出时间课下做一些想做的事情， 这样才是更高效的利用时间</li>
<li>英语英语！ 无论如何， 考研与工作英语都是一件要紧的事情， 背单词， 练口语！</li>
<li>……</li>
</ul>


<p>其实还有很多想要计划的， 暂时想不起来的先跳过……</p>

<h3>关于生活</h3>

<ul>
<li>尽量早睡早起</li>
<li>爱干净， 讲卫生， 勤洗衣服多收拾</li>
<li>发现生活中的美</li>
<li>善待他人， 也善待自己</li>
<li>多读书， 不止是技术书籍</li>
<li>……</li>
</ul>


<h3>关于技术</h3>

<ul>
<li>开源开源， 支持并参与开源项目</li>
<li>认定一个方向， 然后为之努力</li>
<li>读书与实践</li>
<li>编程>n小时</li>
<li>写出经过思考与雕琢的好的技术文章， 不再像这篇文章一样没有营养</li>
<li>……</li>
</ul>


<p>时间紧迫， 先写到这里， 该去上课了……</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Make a program print itself]]></title>
    <link href="http://metooit.github.com/blog/2013/02/26/make-a-program-print-itself/"/>
    <updated>2013-02-26T14:57:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/02/26/make-a-program-print-itself</id>
    <content type="html"><![CDATA[<p>不知道前一段时间在哪里看到这样一个问题， 让一个程序能够打印自身。 刚刚看到这个问题时， 我的第一反应是这还不简单？ 让一个程序打印自身的话， 无非就是
让程序读取自身的文件， 然后逐行打印出来就完了？ 仔细想过之后才发现我有点天真了……</p>

<p>到底让一个程序打印自身难在了哪里呢？</p>

<p>以我的思路来看， 打印自身的程序从文件读取自身然后打印出来涉及到了格式化的问题， 内存分配的问题等； 如果不是这样想， 而是程序本身就包含一个字符串代表
程序本身， 这样打印出来格式化也是首先要考虑的事情吧。</p>

<p>先来看Google给出的几个比较精妙的例子吧：</p>

<ul>
<li>当然， python不负众望， 给出了一个让人很惊艳的解法</li>
</ul>


<figure class='code'><figcaption><span>print-self.py  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">_</span><span class="o">=</span><span class="s">&#39;_=</span><span class="si">%r</span><span class="s">;print _</span><span class="si">%%</span><span class="s">_&#39;</span><span class="p">;</span><span class="k">print</span> <span class="n">_</span><span class="o">%</span><span class="n">_</span>
</span></code></pre></td></tr></table></div></figure>


<p><a href="http://blog.amir.rachum.com/post/28779584872/self-printing-programs-in-python">self-printing-programs-in-python</a></p>

<ul>
<li>然后， 我发现了原来这是一个比较有渊源的程序问题<em>QUINE</em>：
<a href="http://www.nyx.net/~gthompso/quine.htm">The Quine Page</a></li>
</ul>


<p><a href="http://lifegoo.pluskid.org/wiki/Quine.html">打印自身的程序</a></p>

<p><a href="http://notabdc.vip.sina.com/Program/printself.htm">打印自身程序杂谈</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[what should I know about web development]]></title>
    <link href="http://metooit.github.com/blog/2013/02/25/what-should-i-know-about-web-development/"/>
    <updated>2013-02-25T09:52:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/02/25/what-should-i-know-about-web-development</id>
    <content type="html"><![CDATA[<p>其实我一早就很想知道一个网站的开发流程是怎样的， 或许真正去开发一下才会知道， 作为一个程序员到底应该知道那些关于网络开发的事情呢？也许有很多……</p>

<p><a href="http://coolshell.cn/articles/6043.html">Web 开发中需要了解的东西</a>
这就篇文章写了很多关于web开发中很重要也很细节的东西， 可是作为一个初学者我应该知道更为基础的东西。</p>

<p><a href="http://coolshell.cn/articles/4795.html">开源中的一些web资源</a>
总结的这些很全面的web开发资源都很好啊， 收藏在这里先。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C 语言不完全笔记]]></title>
    <link href="http://metooit.github.com/blog/2013/02/22/c-none-complete-note/"/>
    <updated>2013-02-22T20:26:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/02/22/c-none-complete-note</id>
    <content type="html"><![CDATA[<p>今天， 又拾起了《C 程序设计语言》， 想再看一遍， 希望能够真正拾起一些东西吧……</p>

<h2>类型、运算符与表达式</h2>

<ol>
<li>变量名限制： 对内部名而言， 至少前31个字符是有效的； 对外部名而言， ANSI仅保证前六个字符的唯一性， 并且不区分大小写</li>
<li><p>ANSI 表格：</p>

<pre><code>   2 3 4 5 6 7       30 40 50 60 70 80 90 100 110 120
 -------------      ---------------------------------
0:   0 @ P ` p     0:    (  2  &lt;  F  P  Z  d   n   x
1: ! 1 A Q a q     1:    )  3  =  G  Q  [  e   o   y
2: " 2 B R b r     2:    *  4  &gt;  H  R  \  f   p   z
3: # 3 C S c s     3: !  +  5  ?  I  S  ]  g   q   {
4: $ 4 D T d t     4: "  ,  6  @  J  T  ^  h   r   |
5: % 5 E U e u     5: #  -  7  A  K  U  _  i   s   }
6: &amp; 6 F V f v     6: $  .  8  B  L  V  `  j   t   ~
7: ´ 7 G W g w     7: %  /  9  C  M  W  a  k   u  DEL
8: ( 8 H X h x     8: &amp;  0  :  D  N  X  b  l   v
9: ) 9 I Y i y     9: ´  1  ;  E  O  Y  c  m   w
A: * : J Z j z
B: + ; K [ k {
C: , &lt; L \ l |
D: - = M ] m }
E: . &gt; N ^ n ~
F: / ? O _ o DEL
</code></pre></li>
<li>我们通常用&#8217;\0&#8217;代替0以强调某些表达式的字符属性</li>
<li>字符串内部使用&#8217;\0&#8217;结尾， 因此存储字符串的物理单元数量比括在双引号内的字符数多一个</li>
<li>&#8216;x&#8217; 和 &#8220;x&#8221; 是不同的， 前者是一个整数， 其值是字母x在机器字符集中的对应数值； 后者是一个包含一个字符以及&#8217;\a&#8217;的字符数组</li>
<li>&#8216;&amp;&amp;6&#8217; 具有左结合性</li>
<li>为了保证正确性， 在char类型的变量中存储非字符数据，最好要声明是signed 还是unsigned</li>
<li>在if, while, for等测试语句中， 真就意味着非0</li>
<li>赋值是要进行类型转换， 右边的值需要转换成左边的类型</li>
<li>自增运算符与自减运算符只能作用于变量</li>
<li>在不需要任何具体值且仅需要递增变量的情况下， 前缀方式和后缀方式效果相同</li>
<li><code>,</code>运算符是C语言中优先级最低的。某些情况下的逗号并不是逗号运算符， 比如分隔函数参数的逗号， 分隔声明中变量的逗号等， 这些逗号并不保证各个表达式从左到右求值。</li>
<li>函数的返回的表达式将被返回为函数的返回值类型</li>
<li>C语言中一个函数中不允许定义其他函数， 因此函数本身是外部的</li>
<li>如果要在外部变量定义之前使用该变量， 或者外部变量的定义与变量的使用不在同一个文件中，那么必须在相应的变量声明中强制地使用<code>extern</code></li>
<li><code>register</code>声明告诉编译器它所声明的变量在程序中使用的频率较高， 放到寄存器中使程序更小， 执行速度更快</li>
<li>初始化数组时：如果初始化表达式的个数比数组元素少， 则数组后面的元素被初始化为0； 如果初始化表达式的个数比数组元素多， 是错误的</li>
<li>指针只能指向某种特定类型的对象， odi类型的指针可以存放指向任意类型的指针， 但是它不能间接引用其自身</li>
<li>对于数组a[]来讲， &amp;a[i] 与 a + i等价</li>
<li>数组名和指针之间的一个重要区别就是：指针是变量，因此赋值和递增都是合法的； 但是数组名不是变量</li>
<li>在函数定义中的形式参数char s[] 与 char *s 是等价的</li>
<li>C语言保证， 0不是有效的数据地址， 因此返回值0可以用来表示发生了异常事件。*</li>
<li>指针和整数之间不能相互转换， 但是0是唯一的例外</li>
<li>进栈和出栈的标准用法：</li>
</ol>


<figure class='code'><figcaption><span>stack      </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span> <span class="cm">/*将val压入栈*/</span>
</span><span class='line'><span class="n">val</span> <span class="o">=</span> <span class="o">*--</span><span class="n">p</span><span class="p">;</span> <span class="cm">/* 将栈顶元素弹出到val中*/</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>当数组的行数无关紧要时： f(int daytab[][13]) {&#8230;} 与 f(int (<em>daytab)[13]) {&#8230;} 是等价的， 注意第二种方式的int (</em>daytab)[13]中的括号不能去掉。</li>
<li>指针数组的一个重要优点在于数组每一行的长度可以不同</li>
<li>调用主函数main时， 他有两个参数， 第一个参数习惯上成为(argc, 用于参数计算)的值表示运行程序时命令行中参数的数量; 第二个参数(成为argv, 用于参数向量)是一个指向字符串数组的指针，其中每一个字符串对应一个参数， 我们常用多级指针来处理这些字符串。</li>
<li>C语言中，函数本身不是变量，但是可以定义指向函数的指针</li>
<li>结构体<code>struct</code>后面的变量名是可选的，成为结构标记</li>
<li>如果结构声明后面不带变量表， 则不需要为它分配存储空间， 它仅仅描述了一个结构模板或者轮廓</li>
<li>不要认为结构的长度等于各个成员的长度和， 因为不同的对象有不同的对齐要求， 结构中可能会出现空穴。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux 随心小记]]></title>
    <link href="http://metooit.github.com/blog/2013/02/22/linux-quick-view/"/>
    <updated>2013-02-22T14:45:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/02/22/linux-quick-view</id>
    <content type="html"><![CDATA[<h3>Linux 文件权限的概念</h3>

<h4>基本概念：</h4>

<blockquote><p>-rw-rw-r&#8211;  1 prince prince  235 Jan 31 10:20 2013-01-30-hello-world.markdown
[   权限  ]   [用户] [用户组][大小][修改日期]</p></blockquote>

<ul>
<li><p>权限部分：</p></li>
<li><p>第一个字符： <code>d</code>代表目录、 <code>-</code>代表文件、 <code>l</code>代表连接文件</p></li>
<li><p>剩下的九个字符： <code>r</code>代表可读、 <code>w</code>代表可写、 <code>x</code>代表可执行</p></li>
<li><p>大小部分：
大小部分的默认单位是<code>B</code></p></li>
<li><p>时间部分：
如果要查看完整的时间格式，可以使用 <code>ls -l --full-time</code></p></li>
</ul>


<h4>如何改变：</h4>

<ul>
<li><p>改变文件用户组： <code>chgrp</code>
递归更改使用<code>-R</code></p></li>
<li><p>改变文件所有者： <code>chown</code></p></li>
<li><p>改变文件的权限： <code>chmod</code>
两种更改方法： <code>+</code>、 <code>-</code>、 <code>=</code> 方法 和 数字方法, 其中 <code>u</code>、 <code>g</code>、 <code>o</code>、 <code>a</code> 分别代表user, group, others, all</p></li>
</ul>


<h4>目录与文件权限的不同意义：</h4>

<h5>对于文件：</h5>

<ul>
<li><code>r</code> 可读取文件的实际内容</li>
<li><code>w</code> 可编辑、 新增、 修改文件的内容</li>
<li><code>x</code> 该文件有被系统执行的权限</li>
</ul>


<h5>对于目录</h5>

<ul>
<li><code>r</code> 读取目录结构列表的权限</li>
<li><code>w</code> 写入目录的权限： 包括新建文件与目录； 删除已存在的文件或者目录（不论文件的权限为何）； 将已存在的文件或者目录重命名； 转移目录内的文件和目录的位置。</li>
<li><code>x</code> 代表用户能否进入该目录成为工作目录</li>
</ul>


<h3>Linux 目录：</h3>

<h4>几个重要的目录：</h4>

<ul>
<li>/etc 配置文件</li>
<li>/bin 重要的可执行文件</li>
<li>/dev 所需要的设备文件</li>
<li>/lib 执行文件所需要的函数库与内核所需的模块</li>
<li><p>/sbin 重要的系统执行文件</p>

<pre><code>              /
              ├── bin
              ├── boot
              ├── dev
              ├── etc
              ├── home
              ├── lib
              ├── lost+found
              ├── media
              ├── mnt
              ├── opt
              ├── proc
              ├── root
              ├── run
              ├── sbin
              ├── srv
              ├── sys
              ├── tmp
              ├── usr
              ├── var
</code></pre></li>
</ul>


<h4>重点目录：</h4>

<p>/usr : UNIX Software Resource， 里面放置的数据是可分享的不可变动的。
/var : 放置经常变动的文件</p>

<h4>目录相关操作：</h4>

<p><code>cd</code> <code>pwd</code> <code>mkdir</code> <code>rmdir</code></p>

<p>Tips:
* <code>cd -</code> 回到上一个目录
* <code>pwd -P</code> 不显示链接路径而是原本的完整路径
* <code>mkdir -p</code> 创建多层目录
* <code>mkdir -m ??? &lt;dir&gt;</code> 同时设置权限， 否则使用默认的权限
* <code>rmdir -p</code> 连同上层的空目录一起删掉， 要比<code>rm -r</code> 安全</p>

<h4>文件与目录管理：</h4>

<p><code>ls</code> <code>cp</code> <code>rm</code> <code>mv</code></p>

<p>Tips:
* <code>cp -d</code> 若源文件为连接文件， 那么拷贝连接文件而不是文件本身
* <code>cp -i</code> 覆盖前询问
* <code>cp -l</code> 硬连接， <code>cp -s</code> 软连接
* <code>cp -a</code> 保持各种属性不变
* 在命令前面加上<code>\</code>, 可以忽略掉命令的<code>alias</code>指定参数</p>

<h4>文件内容查询：</h4>

<p><code>cat</code> <code>tac</code> <code>nl</code> <code>more</code> <code>less</code> <code>head</code> <code>tail</code> <code>od</code></p>

<p>Tips:
* <code>cat -n</code> 带行号
* <code>od</code> 以二进制方式读取文件内容</p>

<h4>文件目录的默认权限与隐藏权限：</h4>

<p><code>umask</code> 目前用户在新建目录或者文件的时候权限默认值， 使用<code>umask -S</code>更加直观地显示</p>

<h4>查看文件类型：</h4>

<p><code>file</code> 简单地判断文件的类型</p>

<h4>脚本文件名的查询：</h4>

<p><code>which</code></p>

<h4>文件名的查找：</h4>

<p><code>whereis [bmsu] &lt;name&gt;</code> 、 <code>locate</code>、 <code>find</code></p>

<p>Tips:
* <code>locate</code> 是根据已有的数据库来查找的，比较快 /var/lib/mlocate/mlocate.db
* <code>find [PATH] [opinion] [action]</code> &#8212;> <code>find / -perm +7000 -exec ls -l {} \;</code></p>

<h3>文件与文件系统的压缩与打包</h3>

<h3>几个常见的压缩文件扩展名：</h3>

<ul>
<li>.Z compress程序压缩的文件</li>
<li>.gz gzip程序压缩的文件</li>
<li>.bz2 bzip2程序压缩的文件</li>
<li>.tar tar程序打包的数据，并没有压缩过</li>
<li>.tar.gz tar程序打包的文件，其中经过gzip的压缩</li>
<li>.tar.bz2 tar程序打包的文件，其中经过bzip2压缩过</li>
</ul>


<h3>压缩、 查看与解压：</h3>

<ul>
<li><code>compress</code> <code>uncompress</code></li>
<li><code>gzip</code> <code>zcat</code></li>
<li><code>bzip2</code> <code>bzcat</code></li>
</ul>


<h3>打包：</h3>

<ul>
<li><p><code>tar</code>
tar [-] A &#8211;catenate &#8211;concatenate | c &#8211;create | d &#8211;diff &#8211;compare | &#8211;delete | r &#8211;append | t &#8211;list | &#8211;test-label | u &#8211;update | x
&#8211;extract &#8211;get [options] [pathname &#8230;]</p></li>
<li><p>压缩： <code>tar -jcv -f filename.tar.bz2 要被解压缩的文件或目录名称</code></p></li>
<li>查询： <code>tar -jtv -f filename.tar.bz2</code></li>
<li>解压： <code>tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录</code></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lovely Python]]></title>
    <link href="http://metooit.github.com/blog/2013/02/21/lovely-python/"/>
    <updated>2013-02-21T23:41:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/02/21/lovely-python</id>
    <content type="html"><![CDATA[<ul>
<li><p>交互模式下， <code>_</code>代表上一个命令的返回值</p></li>
<li><p>两个挨着的字符串会自动地合并到一起</p></li>
<li><p>Python 的 String 不能被通过索引重新赋值</p></li>
<li><p>s[:i] + s[i:] 相当于 s</p></li>
<li><p>string 索引：</p>

<table>
<thead>
<tr>
<th></th>
<th align="center"> H   </th>
<th align="center"> e   </th>
<th align="center"> l   </th>
<th align="center"> p   </th>
<th align="center"> A   </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center"> 0   </td>
<td align="center"> 1   </td>
<td align="center"> 2   </td>
<td align="center"> 3   </td>
<td align="center"> 4   |</td>
</tr>
<tr>
<td></td>
<td align="center"> -5  </td>
<td align="center"> -4  </td>
<td align="center"> -3  </td>
<td align="center"> -2  </td>
<td align="center"> -1  |</td>
</tr>
</tbody>
</table>
</li>
<li><p>通过分片操作可以实现list的： <code>替换</code>、 <code>删除</code>、 <code>插入</code>、 <code>清空</code></p></li>
<li><p>没有returnd的操作其实也是有返回值的<code>None</code></p></li>
<li><p>函数的默认值在运行过程中只被赋值一次</p></li>
<li><p><code>*</code> 和 <code>**</code></p></li>
<li><p><code>*</code> 可以解包list或者 tumple 作为函数传入的参数</p></li>
<li><p><code>**</code> 可以解包出字典里的key</p></li>
<li><p><code>lambda</code> 形式： 可以创建小的匿名的方法</p></li>
<li><p><code>list</code> 可以被用作： &#8211;> <code>Stacks</code>(pop)  <code>Queues</code>(popleft)</p></li>
<li><p>函数式编程工具：</p>

<blockquote><p>三个内建的可被用在list中的函数： filter(), map(), reduce()</p></blockquote></li>
<li><p>zip() 方便地矩阵转置</p></li>
<li><p>如何读入系统参数： sys.argv[1]</p></li>
<li><p><a href="http://docs.python.org/2/tutorial/inputoutput.html">print 表格</a></p></li>
<li><p>try&#8230;except&#8230; 工作机制： 首先， try后的语句被执行， 如果没有异常发生， except被跳过； 如果有异常发生并且异常的类型与except中的相同， 就用except后的语句进行异常处理。</p></li>
<li><p>可以直接用 x=Class() 来返回一个Class的实例</p></li>
<li><p>这段话要好好理解： Since there is a valid use-case for class-private members (namely to avoid name clashes of names with names defined by subclasses), there is limited support for such a mechanism, called name mangling. Any identifier of the form <strong>spam (at least two leading underscores, at most one trailing underscore) is textually replaced with _classname</strong>spam, where classname is the current class name with leading underscore(s) stripped. This mangling is done without regard to the syntactic position of the identifier, as long as it occurs within the definition of a class.</p></li>
<li><p>实例方法对象拥有变量： m.im_self  m.im_func</p></li>
<li><p><a href="http://docs.python.org/2/tutorial/stdlib.html">标准库</a></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[最小生成树]]></title>
    <link href="http://metooit.github.com/blog/2013/02/21/minimum-spanning-tree/"/>
    <updated>2013-02-21T10:16:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/02/21/minimum-spanning-tree</id>
    <content type="html"><![CDATA[<h2>最小生成树的形成：</h2>

<ul>
<li>问题的前提： 假设有一个连通的无向图G=(V, E)和权重函数w: E->R, 我们希望找到图G中的一棵最小生成树。</li>
<li>主要思想： 我们使用<code>贪心策略</code>来解决此问题。该策略在每个时刻生长最小生成树的一条边，并在整个过程中管理一个边的集合A， 其中A遵守以下循环不变式:

<blockquote><p>在每次循环之前， A是某棵最小生成树的子集。</p></blockquote></li>
</ul>


<p>在每一步，选出一条变(u, v)加入到A中，使得A不违反循环不变式， 并且称这样的边为集合A的<code>安全边</code>。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GENERIC-MST(G, v)
</span><span class='line'>    A=NULL
</span><span class='line'>    while A does not form a spnning tree
</span><span class='line'>        find an edge(u, v)that is safe for A
</span><span class='line'>        A=A&{(u, v)}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>几个概念：

<ul>
<li>切割： 无向图G=(V, E)的一个切割(S, V-S)是集合V的一个划分， 边(u, v)的一端属于集合S， 另一端属于集合(V-S)</li>
<li>尊重： 如果集合A中不存在横跨该切割的边， 则称该切割尊重集合A</li>
<li>轻量级边： 在横跨一个集合所有的边中， 权重最小的边成为轻量级边</li>
</ul>
</li>
</ul>


<h2>Kruskal 算法和 Prim 算法</h2>

<h3>Kruskal:</h3>

<p>主要思想： 在所有连接森林中两棵不同树的边里面， 找到权重最小的边(u, v)。该算法属于贪心算法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>MST-KRUSKAL(G, w)
</span><span class='line'>    A=NULL
</span><span class='line'>    for each vertex v &lt;- G.V
</span><span class='line'>        MAKE-SET(v)
</span><span class='line'>    sort the edges of G.E into nondecreasing order by weight w
</span><span class='line'>    for each edge(u, v) &lt;- G.E taken in nondecreasing order by weight
</span><span class='line'>        if FIND-SET(v) != FIND-SET(v)
</span><span class='line'>            A = A &{(u, v)}
</span><span class='line'>            UNION(u, v)
</span><span class='line'>return A</span></code></pre></td></tr></table></div></figure>


<p><img src="http://metooit.github.com/pictures/kruskal.png" title="kruskal" ></p>

<h3>Prim：</h3>

<p>主要思想： Prim 算法所具有的一个性质是集合A中的边总是构成一棵树。这棵树从一个任意的根结点r开始， 一直长大到覆盖V中的所有结点时为止。算法每一步在A和A之外的结点的所有边中， 选择一条轻量级的边加入A中。并且加入的边也是对A安全的边。</p>

<p><img src="http://metooit.github.com/pictures/Prim.png" title="Prim" ></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>MST-PRIM(G, w, r)
</span><span class='line'>for each u in G.V
</span><span class='line'>    u:key = ...  // 将每个结点的key值设置为无穷（除了根结点r以外， 根结点r的key值设置为0, 以便该结点成为第一个被处理的结点）
</span><span class='line'>    u:PI = NIL  // 将每个结点的父结点设置为NIL， 并对最小优先队列Q进行初始化， 使其包含图中所有的结点
</span><span class='line'>r:key = 0
</span><span class='line'>Q = G.V
</span><span class='line'>while Q != NULL  // 找出横跨切割(V-Q, Q)的轻量级边的一个端点u
</span><span class='line'>    u = EXTRACT-MIN(Q)
</span><span class='line'>    for each v in G.Adj[u]
</span><span class='line'>    if v in Q and w(u, v) &lt; v.key
</span><span class='line'>        v.PI = u
</span><span class='line'>        v.key = w(u, v)</span></code></pre></td></tr></table></div></figure>


<p>Prim 算法的运行时间取决于最小优先队列Q的实现方式。Prim 算法的总时间代价为O(ElgV), 从渐进意义上说它与Kruskal的运行时间相同。</p>

<h2>Kruskal Prim 算法对比：</h2>

<h4>效率对比：</h4>

<ul>
<li>稠密图： Prim > Kruskal</li>
<li>稀疏图： Kruskal > Prim

<h4>空间对比：</h4>

<p>空间上，要根据数据的情况选择使用那种算法：</p></li>
<li>点少边多时： Kruskal</li>
<li>点多边少时： Prim</li>
</ul>


<p><img src="http://metooit.github.com/pictures/historical_tragedy_thum.gif" title="" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[『python 3 程序开发指南』读书笔记 2]]></title>
    <link href="http://metooit.github.com/blog/2013/02/18/notes-for-learning-python-2/"/>
    <updated>2013-02-18T13:43:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/02/18/notes-for-learning-python-2</id>
    <content type="html"><![CDATA[<ul>
<li>python的序列类型：

<ul>
<li>元组： <code>,</code>

<ul>
<li>不能替换删除其中的数据项。可以用list()转换函数将其转换为列表</li>
<li>元组提供了两种方法： count()返回出现次数， index()返回出现位置。</li>
</ul>
</li>
<li>列表： <code>[]</code>

<ul>
<li>列表是可变的</li>
<li>列表的方法，<code>help(list)</code></li>
<li>任意可迭代的列表元组等都可以使用序列拆分操作符进行拆分<code>*</code></li>
</ul>
</li>
</ul>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>>>> first, *rest = [1, 2, 3, 4, 5, 6]
</span><span class='line'>>>> first, rest
</span><span class='line'>(1, [2, 3, 4, 5, 6])
</span><span class='line'>>>> first, *mid, last = [1, 2, 3, 4, 5, 6]
</span><span class='line'>>>> first, mid, last
</span><span class='line'>(1, [2, 3, 4, 5], 6)</span></code></pre></td></tr></table></div></figure>


<pre><code>    * 下面两段代码等价：
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>>>> words[2:4] = []
</span><span class='line'>>>> del words[2:4]</span></code></pre></td></tr></table></div></figure>


<pre><code>    * 带步距的列表：
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>>>> x = [1,2,3,4,5,6,7,8,9,10]
</span><span class='line'>>>> print(x[1::2])
</span><span class='line'>[2, 4, 6, 8, 10]
</span><span class='line'>>>> x[1::2] = [0] * len(x[1::2])
</span><span class='line'>>>> print(x)
</span><span class='line'>[1, 0, 3, 0, 5, 0, 7, 0, 9, 0]</span></code></pre></td></tr></table></div></figure>


<pre><code>    * 列表内涵：
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>>>> leaps = [ y for y in range(1900, 1940)
</span><span class='line'>... if(y % 4 == 0 and y % 100 != 0 or y % 400 == 0)]
</span><span class='line'>>>> print(leaps)
</span><span class='line'>[1904, 1908, 1912, 1916, 1920, 1924, 1928, 1932, 1936]</span></code></pre></td></tr></table></div></figure>


<ul>
<li>集合： <code>{}</code>

<ul>
<li>集合是可变的</li>
<li>集合的方法：<code>help(set)</code></li>
<li>| &amp; \ ^ 操作</li>
<li>集合内涵：</li>
<li>固定集合</li>
</ul>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>>>> html = {x for x in files if x.lower().endswith((".html", "htm"))}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>映射类型：

<ul>
<li>字典：

<ul>
<li>dict是一种无序的组合数据类型</li>
<li>dict()可作为函数调用</li>
<li>字典的键是独一无二的</li>
<li>字典方法： help(dict)</li>
<li>有序字典：</li>
</ul>
</li>
</ul>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>>>> d = collections.OrderedDict(['z', -4], ('e', 19))</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Talk to my heart]]></title>
    <link href="http://metooit.github.com/blog/2013/02/16/talk-to-my-heart/"/>
    <updated>2013-02-16T22:55:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/02/16/talk-to-my-heart</id>
    <content type="html"><![CDATA[<p>忽然觉得应该和自己好好聊一聊， 主要是有几点要提醒一下自己， 算是自我激励或者自我省查吧。</p>

<ul>
<li>第一点： 大多数时候当你决定做一件事情的时候， 要非常非常认真的去做， 要把这件事情当成一件大事去做</li>
<li>第二点： 学习这件事情其实就是自己的事情， 学会这件事情也不是说说那么简单</li>
<li>第三点： 兴趣是最好的老师， 但猎奇不是兴趣， 尝鲜也不是兴趣， 它们只是你在某个无聊的时候找的一些无用的事情来做罢了</li>
<li>第四点： 学会掌控， 学会把握， 每一个结果都有它的原因， 每一次的成功都不是偶然， 所以你要努力尝试去掌控自己的人生</li>
<li>第五点： 做有用的事情， do something that make sense, make difference. 说不好， 自己体会</li>
<li>第六点： 坚持下去不容易， 保持下去有时候很容易， 但是， 你还年轻除了保持不住的青春年华之外其实你没有什么要保持的， 除了…… （比如自信？）， 所以， 大胆去尝试， 大胆去做吧， 做你想做的事</li>
<li>第七点： 如果不是堕落， 其实做你想做的事还是挺难的， 因为有想法不是那么容易的一件事， 所以先要有想法， 然后付诸实施吧！</li>
<li>第八点： 保持阳光的态度， 相信美好的东西</li>
<li>第九点： 简单、执着</li>
<li>第十点： 放轻松…… 再看一看前九点</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Binary Search Tree]]></title>
    <link href="http://metooit.github.com/blog/2013/02/16/binary-search-tree/"/>
    <updated>2013-02-16T13:04:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/02/16/binary-search-tree</id>
    <content type="html"><![CDATA[<h2>Introduction:</h2>

<p>二叉搜索树上的基本操作所花费的时间与树的高度成正比。对于一个有<code>n</code>个结点的二叉搜索树来说， 基本操作的最坏运行时间为<code>O(lgn)</code>。</p>

<h2>1. 二叉搜索树的概念：</h2>

<ul>
<li>一棵二叉搜索树是以一棵二叉树来组织的</li>
<li>树可以用一个链表的数据结构来表示， 其中的每一个结点就是一个对象</li>
<li>除了<code>key</code> 和 <code>卫星数据</code> 外， 每一个结点还包含了属性 <code>left</code> <code>right</code> 和 <code>p</code>。 如果相应的属性不存在， 那么它的值就是<code>NIL</code>。 根结点是树中唯一一个父指针为NIL的结点。</li>
<li>对于任何节点x， 它的左子树中的关键字最大不能大于x.key, 右子树中的关键字最小不能小于x.key</li>
</ul>


<h2>2. 二叉搜索树上的操作：</h2>

<h3>2.1 如何按序打印二叉树：</h3>

<ul>
<li><p>二叉搜索树的性质决定了我们可以通过简单的<code>递归算法</code>来按顺序打印出二叉树的所有关键字。这种方法称作是<code>中序遍历</code>（inorder tree walk）</p>

<p>** 中序遍历： 输出的子树根的关键字位于其左子树关键字和右子树关键字之间</p>

<p>** 先序遍历： 输出的根的关键字在其左右子树关键字之前</p>

<p>** 后序遍历： 输出的根的关键字在其左右子树关键字之后</p></li>
<li><p>伪代码实现：</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>INORDER-TREE-WALK(x)
</span><span class='line'>    if x != NIL
</span><span class='line'>        INORDER-TREE-WALK(x.left)
</span><span class='line'>        print x.key
</span><span class='line'>        INORDER-TREE-WALK(x.right)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>遍历打印一个有n个结点的二叉搜索树需要耗费O(n)的时间 （证明详见《算法导论（第三版）》）</li>
</ul>


<h3>2.2 查询二叉搜索树：</h3>

<h4>2.2.1查找：</h4>

<ul>
<li>差找是指在一棵二叉搜索数中找到一个具有给定关键字的结点</li>
<li>输入是一个指向树根的指针和一个关键字<code>k</code>, 如果结点存在则返回指向该关键字的指针，否则返回<code>NIL</code></li>
<li>伪代码实现：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>TREE-SEARCH(x, k)
</span><span class='line'>    if x == NIL or k == x.key
</span><span class='line'>        return x
</span><span class='line'>    if x &lt; x.key
</span><span class='line'>        return TREE-SEARCH(x.left, k)
</span><span class='line'>    else
</span><span class='line'>        return TREE-SEARCH(x.right, k)</span></code></pre></td></tr></table></div></figure>


<p><img src="http://metooit.github.com/pictures/BSTree.jpg" title="BSTree" ></p>

<ul>
<li><p>TREE-SEARCH 的运行时间为O(h) (h 是指树的高度)</p></li>
<li><p>我们也可以不用递归， 用<code>while</code>循环来展开</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ITERATIVE-TREE_SEARCH(x, k)
</span><span class='line'>    whiel x != NIL and k != x.key
</span><span class='line'>        if x &lt; x.key
</span><span class='line'>            x = x.left
</span><span class='line'>        else x = x.right
</span><span class='line'>    return x</span></code></pre></td></tr></table></div></figure>


<h4>2.2.2 最大和最小关键字元素：</h4>

<ul>
<li>查找最小关键字的元素：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>TREE-MINIMUM(x)
</span><span class='line'>    while x.left != NIL
</span><span class='line'>        x = x.left
</span><span class='line'>    return x</span></code></pre></td></tr></table></div></figure>


<ul>
<li>查找最大关键字的元素：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>TREE-MAXIMUM(x)
</span><span class='line'>    while x.right != NIL
</span><span class='line'>        x = x.right
</span><span class='line'>    return x</span></code></pre></td></tr></table></div></figure>


<ul>
<li>这两个过程的运行时间为O(h)</li>
</ul>


<h4>2.2.3 后继和前驱：</h4>

<ul>
<li>伪代码的实现过程：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>TREE-SUCCESSOR(x)
</span><span class='line'>    if x.right != NIL
</span><span class='line'>        return TREE-MINIMUM(x.right)
</span><span class='line'>    y = x.p
</span><span class='line'>    while y != NIL and x == y.right
</span><span class='line'>        x = y
</span><span class='line'>        y = y.p</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>两种情况：
<strong> 如果结点x的右子树为非空，那么x的后继恰好是x右子树中的最左的结点
</strong> 如果结点x的右子树非空并且有一个后继y， 那么y就是x的有左孩子的底层祖先， 并且它也是x的一个祖先， 为了找到y， 只需要简单地从x开始沿树而上直到遇到一个其双亲有左孩子的结点</p></li>
<li><p>执行此过程的操作时间同样是O(h)</p></li>
</ul>


<h3>2.3 查找和删除：</h3>

<h4>2.3.1 插入：</h4>

<ul>
<li><p>前提条件： 将一个新值v插入到一棵二叉搜索树T中， 以z作为输入， 其中z.key=v, z.left=NIL, z.right=NIL</p></li>
<li><p>伪代码实现：</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>TREE-INSERT(T, z)
</span><span class='line'>    y = NIL
</span><span class='line'>    x = T.root
</span><span class='line'>    while x != NIL
</span><span class='line'>        y = x
</span><span class='line'>        if z.key &lt; x.key
</span><span class='line'>            x = x.left
</span><span class='line'>        else
</span><span class='line'>            x = x.right
</span><span class='line'>    z.p = y
</span><span class='line'>    if y == NIL
</span><span class='line'>        T.root = z // tree T was empty
</span><span class='line'>    elseif z.key &lt; y.key
</span><span class='line'>        y.left = z
</span><span class='line'>    else
</span><span class='line'>        y.right = z</span></code></pre></td></tr></table></div></figure>


<ul>
<li>TREE-INSERT 的运行时间为O(h)</li>
</ul>


<h4>2.3.2 删除：</h4>

<ul>
<li>一棵二叉搜索树中删除一个结点z的整个策略分为三种基本情况：</li>
<li>如果z没有孩子结点， 那么只是简单地将它删除， 并且修改它的父结点， 用NIL作为孩子来替换z
<img src="http://metooit.github.com/pictures/delete1.png" title="delete1" ></li>
<li>如果z只有一个孩子， 那么将这个孩子提升到树中z的位置上， 并且修改z的父结点， 用z的孩子来替换z
<img src="http://metooit.github.com/pictures/delete2.png" title="delete2" ></li>
<li><p>如果z有两个孩子， 那么找到z的后继y（一定在z的右子树中）， 并且让y占据树中z的位置。 z的原来右子树部分成为y的新右子树， 并且z的左子树成为y的新的左子树。
<img src="http://metooit.github.com/pictures/delete3.png" title="delete3" ></p></li>
<li><p>从一棵二叉搜索树中删除一个结点，如果取指向T和z的指针作为输入：</p></li>
<li>如果z没有左孩子， 那么用其右孩子来替换z， 这个右孩子可以是NIL也可以不是. 当z的右孩子是NIL时， 这种情况就是z只有一个孩子结点的情况。 当z的右孩子非NIL时， 这种情况就是z仅有一个孩子结点的情形， 该孩子是其右孩子。</li>
<li>如果z仅有一个孩子并且为其左孩子时， 那么用左孩子来替换z</li>
<li>否则， z两个孩子都有。 我们要查找z的后继y，这个后继位于z的右子树中并且没有左孩子。 现在需要将y移出原来的位置进行拼接， 并替换树中的z</li>
<li><p>如果y是z的右孩子， 那么用y替换z， 并仅留下y的右孩子</p></li>
<li><p>为了在二叉树中移动子树， 定义TRANSPLANT， 用另一棵子树替换一棵子树并且成为其双亲的孩子结点。</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>TRANSPLANT(T, u, v)
</span><span class='line'>    if u.p == NIL
</span><span class='line'>        T.root = v
</span><span class='line'>    elseif u == u.p.left
</span><span class='line'>        u.p.left = v
</span><span class='line'>    else u.p.right = v
</span><span class='line'>    if v != NIL
</span><span class='line'>        v.p = u.p</span></code></pre></td></tr></table></div></figure>


<ul>
<li>从二叉树中删除结点的过程伪代码：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>TREE-DELETE(T, z)
</span><span class='line'>    if z.left = NIL
</span><span class='line'>        TRANSPLANT(T, z, z.right)
</span><span class='line'>    elseif z.right == NIL
</span><span class='line'>        TRANSPLANT(T, z, z.left)
</span><span class='line'>    else y = TREE-MINIMUM(z.right)
</span><span class='line'>        if y.p != z
</span><span class='line'>            TRANSPLANT(T, y, y.right)
</span><span class='line'>            y.right = z.right
</span><span class='line'>            y.right.p = y
</span><span class='line'>        TRANSPLANT(T, z, y)
</span><span class='line'>        y.left = z.left
</span><span class='line'>        y.left.p = y</span></code></pre></td></tr></table></div></figure>


<ul>
<li>从一棵高度为h的二叉树上删除一个结点的时间代价为O(h)</li>
</ul>


<h3>源代码实现：</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Initialize the binary tree, generate the root node */
</span><span class='line'>Tree_Node* TreeInit(Tree_Node_Key key)
</span><span class='line'>{
</span><span class='line'>    Tree_Node* Start = NULL;
</span><span class='line'>    if ((Start = malloc(sizeof(Tree_Node))) == NULL)
</span><span class='line'>    {
</span><span class='line'>        fprintf(stderr, "Failed to initialize memory\n");
</span><span class='line'>        exit(EXIT_FAILURE);
</span><span class='line'>    }
</span><span class='line'>    Start->key = key;
</span><span class='line'>    Start->left = NULL;
</span><span class='line'>    Start->right = NULL;
</span><span class='line'>    return Start;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/* Insert the given key to the Tree */
</span><span class='line'>Tree_Node* TreeInsert(Tree_Node* Start, Tree_Node_Key key)
</span><span class='line'>{
</span><span class='line'>    if(Start == NULL) {
</span><span class='line'>        return (TreeInit(key));
</span><span class='line'>    }
</span><span class='line'>    else {
</span><span class='line'>        if(Start->key > key)
</span><span class='line'>            Start->left = TreeInsert(Start->left, key);
</span><span class='line'>        else
</span><span class='line'>            Start->right = TreeInsert(Start->right, key);
</span><span class='line'>        return Start;
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>/* Find the node that contains the min key */
</span><span class='line'>Tree_Node* TreeMinimum(Tree_Node* Start)
</span><span class='line'>{
</span><span class='line'>    while(Start->left != NULL)
</span><span class='line'>    {
</span><span class='line'>        Start = Start->left;
</span><span class='line'>    }
</span><span class='line'>    return Start;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/* Find the node that contains the max key */
</span><span class='line'>Tree_Node* TreeMaximum(Tree_Node* Start)
</span><span class='line'>{
</span><span class='line'>    while(Start->right != NULL)
</span><span class='line'>    {
</span><span class='line'>        Start = Start->right;
</span><span class='line'>    }
</span><span class='line'>    return Start;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/* Print the tree in order */
</span><span class='line'>void InorderPrintTree(Tree_Node* Start)
</span><span class='line'>{
</span><span class='line'>    if(Start == NULL)
</span><span class='line'>        return;
</span><span class='line'>    InorderPrintTree(Start->left);
</span><span class='line'>    printf("%d ", Start->key);
</span><span class='line'>    InorderPrintTree(Start->right);
</span><span class='line'>    return;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/* Print the tree in postorder */
</span><span class='line'>void PostorderPrintTree(Tree_Node* Start)
</span><span class='line'>{
</span><span class='line'>    if(Start == NULL)
</span><span class='line'>        return;
</span><span class='line'>    PostorderPrintTree(Start->left);
</span><span class='line'>    PostorderPrintTree(Start->right);
</span><span class='line'>    printf("%d ", Start->key);
</span><span class='line'>    return;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/* Using recurse to free the tree */
</span><span class='line'>void TreeFreeRecurse(Tree_Node* Start)
</span><span class='line'>{
</span><span class='line'>    if(Start == NULL)
</span><span class='line'>        return;
</span><span class='line'>    else {
</span><span class='line'>        TreeFreeRecurse(Start->left);
</span><span class='line'>        TreeFreeRecurse(Start->right);
</span><span class='line'>    }
</span><span class='line'>    free(Start->left);
</span><span class='line'>    free(Start->right);
</span><span class='line'>    return;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/* Free the space of the tree */
</span><span class='line'>void TreeFree(Tree_Node* Start)
</span><span class='line'>{
</span><span class='line'>    TreeFreeRecurse(Start);
</span><span class='line'>    free(Start);
</span><span class='line'>    return;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/* Return the tree size */
</span><span class='line'>int TreeSize(Tree_Node* Start)
</span><span class='line'>{
</span><span class='line'>    if (Start == NULL) return 0;
</span><span class='line'>    else return 1 + TreeSize(Start->left) + TreeSize(Start->right);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/* Return the max depth of the tree */
</span><span class='line'>int TreeMaxDepth(Tree_Node* Start)
</span><span class='line'>{
</span><span class='line'>    if(Start == NULL)
</span><span class='line'>        return 0;
</span><span class='line'>
</span><span class='line'>    if(TreeMaxDepth(Start->left) >= TreeMaxDepth(Start->right))
</span><span class='line'>        return TreeMaxDepth(Start->left) + 1;
</span><span class='line'>    else
</span><span class='line'>        return TreeMaxDepth(Start->right) + 1;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<hr />

<h3>References:</h3>

<ul>
<li><a href="http://www.qmatica.com/DataStructures/Trees/AVL/AVLTree.html">动画演示</a></li>
<li><a href="http://cslibrary.stanford.edu/110/BinaryTrees.html">Binary Trees</a></li>
<li><a href="http://lonelycoder.org/?p=142">A simple introduction to Binary Search Tree</a></li>
<li><a href="http://www.wutianqi.com/?p=2430">《算法导论》学习笔记</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Style]]></title>
    <link href="http://metooit.github.com/blog/2013/02/16/ruby-style-gide/"/>
    <updated>2013-02-16T09:34:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/02/16/ruby-style-gide</id>
    <content type="html"><![CDATA[<blockquote><p>Style is what separates the good from the great.</p></blockquote>

<p><a href="https://github.com/bbatsov/ruby-style-guide">Ruby Style Guide</a></p>

<p><a href="https://github.com/JuanitoFatas/ruby-style-guide/blob/master/README-zhCN.md">简体版本</a></p>

<h2>读书笔记：</h2>

<h3>源代码排版：</h3>

<ul>
<li>使用空格来围绕操作符： 唯一的例外是使用指数操作的时候</li>
<li>把<code>when</code>和<code>case</code>缩排在同一层</li>
<li>在<code>def</code>之间使用空行， 并且把方法分成合乎逻辑的段落</li>
<li>当一个方法呼叫叫的参数过长时， 排列它们</li>
<li>长的常量数字加底线来提高可读性</li>
<li>不要在注解区块和<code>def</code>之间放一个空行</li>
<li>每一行限制在80个字符</li>
<li>避免尾随的空白</li>
</ul>


<h3>语法：</h3>

<ul>
<li><code>def</code>接收参数时使用括号， 没有参数时省略括号</li>
<li>永远不要使用<code>for</code>， 除非你知道为什么， 一般用迭代器来取代</li>
<li>永远不要在多行的<code>if</code>&#8230;<code>unless</code>中使用<code>then</code></li>
<li>偏爱三元操作符 <code>?:</code> 胜于 <code>if/then/else/end</code> 结构</li>
<li>使用表达式来给三元操作符分支， 这意味着三元操作符不能嵌套</li>
<li>布尔表达式使用 &amp;&amp;/||, 控制流程使用 and/or</li>
<li>偏爱 <code>if/unless</code> 修饰符当你有单行的主体， 或者使用控制流程的 <code>and/or</code></li>
<li>否定条件偏爱<code>unless</code> 胜于 <code>if</code></li>
<li>永远不要使用 <code>unless</code> 搭配 <code>else</code></li>
<li>不要使用圆括号围绕 <code>if/unless/while</code> 的条件表达式， 除非这个表达式包含了一个赋值</li>
<li>当你有单行的主体时， 偏爱<code>while/until</code> 修饰符</li>
<li>忽略围绕方法参数的括号</li>
<li>单行区块偏爱<code>{...}</code> 胜于 <code>do...end</code> 多行区块避免使用 <code>{...}</code></li>
<li>避免在不需要控制流程的场合使用 <code>return</code></li>
<li>避免在不需要的情况使用 <code>self</code></li>
<li>避免使用带有局域变量的 <code>shadowing</code> 方法</li>
<li>赋予默认值给方法的参数时需要使用空格来围绕 <code>=</code></li>
<li>使用 <code>||=</code> 来初始化变量， 不要使用该符号初始化布尔变量</li>
<li>避免在方法名和做括号之间放一个空格</li>
<li>如果方法的第一个参数由左括号开始， 那么方法参数应该使用括号</li>
<li>偏好使用<code>lambda</code>新语法</li>
<li>未使用的区块参数用 <code>_</code></li>
</ul>


<h3>命名：</h3>

<ul>
<li>方法与变量使用蛇底式小写</li>
<li>类别与模组使用陀峰方式</li>
<li>其他常数使用蛇底式大写</li>
<li>返回布尔值的方法用 <code>?</code> 结尾</li>
<li>若潜在危险的方法有安全的版本存在时， 应该使用 <code>!</code> 结尾</li>
</ul>


<hr />

<p>（未完待续……）</p>
]]></content>
  </entry>
  
</feed>
