<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[K.I.S.S]]></title>
  <link href="http://metooit.github.com/atom.xml" rel="self"/>
  <link href="http://metooit.github.com/"/>
  <updated>2013-02-23T22:37:13+08:00</updated>
  <id>http://metooit.github.com/</id>
  <author>
    <name><![CDATA[metooit]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C 语言不完全笔记]]></title>
    <link href="http://metooit.github.com/blog/2013/02/22/c-none-complete-note/"/>
    <updated>2013-02-22T20:26:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/02/22/c-none-complete-note</id>
    <content type="html"><![CDATA[<p>今天， 又拾起了《C 程序设计语言》， 想再看一遍， 希望能够真正拾起一些东西吧……</p>

<h2>类型、运算符与表达式</h2>

<ol>
<li>变量名限制： 对内部名而言， 至少前31个字符是有效的； 对外部名而言， ANSI仅保证前六个字符的唯一性， 并且不区分大小写</li>
<li><p>ANSI 表格：</p>

<pre><code>   2 3 4 5 6 7       30 40 50 60 70 80 90 100 110 120
 -------------      ---------------------------------
0:   0 @ P ` p     0:    (  2  &lt;  F  P  Z  d   n   x
1: ! 1 A Q a q     1:    )  3  =  G  Q  [  e   o   y
2: " 2 B R b r     2:    *  4  &gt;  H  R  \  f   p   z
3: # 3 C S c s     3: !  +  5  ?  I  S  ]  g   q   {
4: $ 4 D T d t     4: "  ,  6  @  J  T  ^  h   r   |
5: % 5 E U e u     5: #  -  7  A  K  U  _  i   s   }
6: &amp; 6 F V f v     6: $  .  8  B  L  V  `  j   t   ~
7: ´ 7 G W g w     7: %  /  9  C  M  W  a  k   u  DEL
8: ( 8 H X h x     8: &amp;  0  :  D  N  X  b  l   v
9: ) 9 I Y i y     9: ´  1  ;  E  O  Y  c  m   w
A: * : J Z j z
B: + ; K [ k {
C: , &lt; L \ l |
D: - = M ] m }
E: . &gt; N ^ n ~
F: / ? O _ o DEL
</code></pre></li>
<li>我们通常用&#8217;\0&#8217;代替0以强调某些表达式的字符属性</li>
<li>字符串内部使用&#8217;\0&#8217;结尾， 因此存储字符串的物理单元数量比括在双引号内的字符数多一个</li>
<li>&#8216;x&#8217; 和 &#8220;x&#8221; 是不同的， 前者是一个整数， 其值是字母x在机器字符集中的对应数值； 后者是一个包含一个字符以及&#8217;\a&#8217;的字符数组</li>
<li>&#8216;&amp;&amp;6&#8217; 具有左结合性</li>
<li>为了保证正确性， 在char类型的变量中存储非字符数据，最好要声明是signed 还是unsigned</li>
<li>在if, while, for等测试语句中， 真就意味着非0</li>
<li>赋值是要进行类型转换， 右边的值需要转换成左边的类型</li>
<li>自增运算符与自减运算符只能作用于变量</li>
<li>在不需要任何具体值且仅需要递增变量的情况下， 前缀方式和后缀方式效果相同</li>
<li><code>,</code>运算符是C语言中优先级最低的。某些情况下的逗号并不是逗号运算符， 比如分隔函数参数的逗号， 分隔声明中变量的逗号等， 这些逗号并不保证各个表达式从左到右求值。</li>
<li>函数的返回的表达式将被返回为函数的返回值类型</li>
<li>C语言中一个函数中不允许定义其他函数， 因此函数本身是外部的</li>
<li>如果要在外部变量定义之前使用该变量， 或者外部变量的定义与变量的使用不在同一个文件中，那么必须在相应的变量声明中强制地使用<code>extern</code></li>
<li><code>register</code>声明告诉编译器它所声明的变量在程序中使用的频率较高， 放到寄存器中使程序更小， 执行速度更快</li>
<li>初始化数组时：如果初始化表达式的个数比数组元素少， 则数组后面的元素被初始化为0； 如果初始化表达式的个数比数组元素多， 是错误的</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux 随心小记]]></title>
    <link href="http://metooit.github.com/blog/2013/02/22/linux-quick-view/"/>
    <updated>2013-02-22T14:45:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/02/22/linux-quick-view</id>
    <content type="html"><![CDATA[<h3>Linux 文件权限的概念</h3>

<h4>基本概念：</h4>

<blockquote><p>-rw-rw-r&#8211;  1 prince prince  235 Jan 31 10:20 2013-01-30-hello-world.markdown
[   权限  ]   [用户] [用户组][大小][修改日期]</p></blockquote>

<ul>
<li><p>权限部分：</p></li>
<li><p>第一个字符： <code>d</code>代表目录、 <code>-</code>代表文件、 <code>l</code>代表连接文件</p></li>
<li><p>剩下的九个字符： <code>r</code>代表可读、 <code>w</code>代表可写、 <code>x</code>代表可执行</p></li>
<li><p>大小部分：
大小部分的默认单位是<code>B</code></p></li>
<li><p>时间部分：
如果要查看完整的时间格式，可以使用 <code>ls -l --full-time</code></p></li>
</ul>


<h4>如何改变：</h4>

<ul>
<li><p>改变文件用户组： <code>chgrp</code>
递归更改使用<code>-R</code></p></li>
<li><p>改变文件所有者： <code>chown</code></p></li>
<li><p>改变文件的权限： <code>chmod</code>
两种更改方法： <code>+</code>、 <code>-</code>、 <code>=</code> 方法 和 数字方法, 其中 <code>u</code>、 <code>g</code>、 <code>o</code>、 <code>a</code> 分别代表user, group, others, all</p></li>
</ul>


<h4>目录与文件权限的不同意义：</h4>

<h5>对于文件：</h5>

<ul>
<li><code>r</code> 可读取文件的实际内容</li>
<li><code>w</code> 可编辑、 新增、 修改文件的内容</li>
<li><code>x</code> 该文件有被系统执行的权限</li>
</ul>


<h5>对于目录</h5>

<ul>
<li><code>r</code> 读取目录结构列表的权限</li>
<li><code>w</code> 写入目录的权限： 包括新建文件与目录； 删除已存在的文件或者目录（不论文件的权限为何）； 将已存在的文件或者目录重命名； 转移目录内的文件和目录的位置。</li>
<li><code>x</code> 代表用户能否进入该目录成为工作目录</li>
</ul>


<h3>Linux 目录：</h3>

<h4>几个重要的目录：</h4>

<ul>
<li>/etc 配置文件</li>
<li>/bin 重要的可执行文件</li>
<li>/dev 所需要的设备文件</li>
<li>/lib 执行文件所需要的函数库与内核所需的模块</li>
<li><p>/sbin 重要的系统执行文件</p>

<pre><code>              /
              ├── bin
              ├── boot
              ├── dev
              ├── etc
              ├── home
              ├── lib
              ├── lost+found
              ├── media
              ├── mnt
              ├── opt
              ├── proc
              ├── root
              ├── run
              ├── sbin
              ├── srv
              ├── sys
              ├── tmp
              ├── usr
              ├── var
</code></pre></li>
</ul>


<h4>重点目录：</h4>

<p>/usr : UNIX Software Resource， 里面放置的数据是可分享的不可变动的。
/var : 放置经常变动的文件</p>

<h4>目录相关操作：</h4>

<p><code>cd</code> <code>pwd</code> <code>mkdir</code> <code>rmdir</code></p>

<p>Tips:
* <code>cd -</code> 回到上一个目录
* <code>pwd -P</code> 不显示链接路径而是原本的完整路径
* <code>mkdir -p</code> 创建多层目录
* <code>mkdir -m ??? &lt;dir&gt;</code> 同时设置权限， 否则使用默认的权限
* <code>rmdir -p</code> 连同上层的空目录一起删掉， 要比<code>rm -r</code> 安全</p>

<h4>文件与目录管理：</h4>

<p><code>ls</code> <code>cp</code> <code>rm</code> <code>mv</code></p>

<p>Tips:
* <code>cp -d</code> 若源文件为连接文件， 那么拷贝连接文件而不是文件本身
* <code>cp -i</code> 覆盖前询问
* <code>cp -l</code> 硬连接， <code>cp -s</code> 软连接
* <code>cp -a</code> 保持各种属性不变
* 在命令前面加上<code>\</code>, 可以忽略掉命令的<code>alias</code>指定参数</p>

<h4>文件内容查询：</h4>

<p><code>cat</code> <code>tac</code> <code>nl</code> <code>more</code> <code>less</code> <code>head</code> <code>tail</code> <code>od</code></p>

<p>Tips:
* <code>cat -n</code> 带行号
* <code>od</code> 以二进制方式读取文件内容</p>

<h4>文件目录的默认权限与隐藏权限：</h4>

<p><code>umask</code> 目前用户在新建目录或者文件的时候权限默认值， 使用<code>umask -S</code>更加直观地显示</p>

<h4>查看文件类型：</h4>

<p><code>file</code> 简单地判断文件的类型</p>

<h4>脚本文件名的查询：</h4>

<p><code>which</code></p>

<h4>文件名的查找：</h4>

<p><code>whereis [bmsu] &lt;name&gt;</code> 、 <code>locate</code>、 <code>find</code></p>

<p>Tips:
* <code>locate</code> 是根据已有的数据库来查找的，比较快 /var/lib/mlocate/mlocate.db
* <code>find [PATH] [opinion] [action]</code> &#8212;> <code>find / -perm +7000 -exec ls -l {} \;</code></p>

<h3>文件与文件系统的压缩与打包</h3>

<h3>几个常见的压缩文件扩展名：</h3>

<ul>
<li>.Z compress程序压缩的文件</li>
<li>.gz gzip程序压缩的文件</li>
<li>.bz2 bzip2程序压缩的文件</li>
<li>.tar tar程序打包的数据，并没有压缩过</li>
<li>.tar.gz tar程序打包的文件，其中经过gzip的压缩</li>
<li>.tar.bz2 tar程序打包的文件，其中经过bzip2压缩过</li>
</ul>


<h3>压缩、 查看与解压：</h3>

<ul>
<li><code>compress</code> <code>uncompress</code></li>
<li><code>gzip</code> <code>zcat</code></li>
<li><code>bzip2</code> <code>bzcat</code></li>
</ul>


<h3>打包：</h3>

<ul>
<li><p><code>tar</code>
tar [-] A &#8211;catenate &#8211;concatenate | c &#8211;create | d &#8211;diff &#8211;compare | &#8211;delete | r &#8211;append | t &#8211;list | &#8211;test-label | u &#8211;update | x
&#8211;extract &#8211;get [options] [pathname &#8230;]</p></li>
<li><p>压缩： <code>tar -jcv -f filename.tar.bz2 要被解压缩的文件或目录名称</code></p></li>
<li>查询： <code>tar -jtv -f filename.tar.bz2</code></li>
<li>解压： <code>tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录</code></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lovely Python]]></title>
    <link href="http://metooit.github.com/blog/2013/02/21/lovely-python/"/>
    <updated>2013-02-21T23:41:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/02/21/lovely-python</id>
    <content type="html"><![CDATA[<ul>
<li><p>交互模式下， <code>_</code>代表上一个命令的返回值</p></li>
<li><p>两个挨着的字符串会自动地合并到一起</p></li>
<li><p>Python 的 String 不能被通过索引重新赋值</p></li>
<li><p>s[:i] + s[i:] 相当于 s</p></li>
<li><p>string 索引：</p>

<table>
<thead>
<tr>
<th></th>
<th align="center"> H   </th>
<th align="center"> e   </th>
<th align="center"> l   </th>
<th align="center"> p   </th>
<th align="center"> A   </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center"> 0   </td>
<td align="center"> 1   </td>
<td align="center"> 2   </td>
<td align="center"> 3   </td>
<td align="center"> 4   |</td>
</tr>
<tr>
<td></td>
<td align="center"> -5  </td>
<td align="center"> -4  </td>
<td align="center"> -3  </td>
<td align="center"> -2  </td>
<td align="center"> -1  |</td>
</tr>
</tbody>
</table>
</li>
<li><p>通过分片操作可以实现list的： <code>替换</code>、 <code>删除</code>、 <code>插入</code>、 <code>清空</code></p></li>
<li><p>没有returnd的操作其实也是有返回值的<code>None</code></p></li>
<li><p>函数的默认值在运行过程中只被赋值一次</p></li>
<li><p><code>*</code> 和 <code>**</code></p></li>
<li><p><code>*</code> 可以解包list或者 tumple 作为函数传入的参数</p></li>
<li><p><code>**</code> 可以解包出字典里的key</p></li>
<li><p><code>lambda</code> 形式： 可以创建小的匿名的方法</p></li>
<li><p><code>list</code> 可以被用作： &#8211;> <code>Stacks</code>(pop)  <code>Queues</code>(popleft)</p></li>
<li><p>函数式编程工具：</p>

<blockquote><p>三个内建的可被用在list中的函数： filter(), map(), reduce()</p></blockquote></li>
<li><p>zip() 方便地矩阵转置</p></li>
<li><p>如何读入系统参数： sys.argv[1]</p></li>
<li><p><a href="http://docs.python.org/2/tutorial/inputoutput.html">print 表格</a></p></li>
<li><p>try&#8230;except&#8230; 工作机制： 首先， try后的语句被执行， 如果没有异常发生， except被跳过； 如果有异常发生并且异常的类型与except中的相同， 就用except后的语句进行异常处理。</p></li>
<li><p>可以直接用 x=Class() 来返回一个Class的实例</p></li>
<li><p>这段话要好好理解： Since there is a valid use-case for class-private members (namely to avoid name clashes of names with names defined by subclasses), there is limited support for such a mechanism, called name mangling. Any identifier of the form <strong>spam (at least two leading underscores, at most one trailing underscore) is textually replaced with _classname</strong>spam, where classname is the current class name with leading underscore(s) stripped. This mangling is done without regard to the syntactic position of the identifier, as long as it occurs within the definition of a class.</p></li>
<li><p>实例方法对象拥有变量： m.im_self  m.im_func</p></li>
<li><p><a href="http://docs.python.org/2/tutorial/stdlib.html">标准库</a></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[最小生成树]]></title>
    <link href="http://metooit.github.com/blog/2013/02/21/minimum-spanning-tree/"/>
    <updated>2013-02-21T10:16:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/02/21/minimum-spanning-tree</id>
    <content type="html"><![CDATA[<h2>最小生成树的形成：</h2>

<ul>
<li>问题的前提： 假设有一个连通的无向图G=(V, E)和权重函数w: E->R, 我们希望找到图G中的一棵最小生成树。</li>
<li>主要思想： 我们使用<code>贪心策略</code>来解决此问题。该策略在每个时刻生长最小生成树的一条边，并在整个过程中管理一个边的集合A， 其中A遵守以下循环不变式:

<blockquote><p>在每次循环之前， A是某棵最小生成树的子集。</p></blockquote></li>
</ul>


<p>在每一步，选出一条变(u, v)加入到A中，使得A不违反循环不变式， 并且称这样的边为集合A的<code>安全边</code>。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GENERIC-MST(G, v)
</span><span class='line'>    A=NULL
</span><span class='line'>    while A does not form a spnning tree
</span><span class='line'>        find an edge(u, v)that is safe for A
</span><span class='line'>        A=A&{(u, v)}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>几个概念：

<ul>
<li>切割： 无向图G=(V, E)的一个切割(S, V-S)是集合V的一个划分， 边(u, v)的一端属于集合S， 另一端属于集合(V-S)</li>
<li>尊重： 如果集合A中不存在横跨该切割的边， 则称该切割尊重集合A</li>
<li>轻量级边： 在横跨一个集合所有的边中， 权重最小的边成为轻量级边</li>
</ul>
</li>
</ul>


<h2>Kruskal 算法和 Prim 算法</h2>

<h3>Kruskal:</h3>

<p>主要思想： 在所有连接森林中两棵不同树的边里面， 找到权重最小的边(u, v)。该算法属于贪心算法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>MST-KRUSKAL(G, w)
</span><span class='line'>    A=NULL
</span><span class='line'>    for each vertex v &lt;- G.V
</span><span class='line'>        MAKE-SET(v)
</span><span class='line'>    sort the edges of G.E into nondecreasing order by weight w
</span><span class='line'>    for each edge(u, v) &lt;- G.E taken in nondecreasing order by weight
</span><span class='line'>        if FIND-SET(v) != FIND-SET(v)
</span><span class='line'>            A = A &{(u, v)}
</span><span class='line'>            UNION(u, v)
</span><span class='line'>return A</span></code></pre></td></tr></table></div></figure>


<p><img src="http://metooit.github.com/pictures/kruskal.png" title="kruskal" ></p>

<h3>Prim：</h3>

<p>主要思想： Prim 算法所具有的一个性质是集合A中的边总是构成一棵树。这棵树从一个任意的根结点r开始， 一直长大到覆盖V中的所有结点时为止。算法每一步在A和A之外的结点的所有边中， 选择一条轻量级的边加入A中。并且加入的边也是对A安全的边。</p>

<p><img src="http://metooit.github.com/pictures/Prim.png" title="Prim" ></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>MST-PRIM(G, w, r)
</span><span class='line'>for each u in G.V
</span><span class='line'>    u:key = ...  // 将每个结点的key值设置为无穷（除了根结点r以外， 根结点r的key值设置为0, 以便该结点成为第一个被处理的结点）
</span><span class='line'>    u:PI = NIL  // 将每个结点的父结点设置为NIL， 并对最小优先队列Q进行初始化， 使其包含图中所有的结点
</span><span class='line'>r:key = 0
</span><span class='line'>Q = G.V
</span><span class='line'>while Q != NULL  // 找出横跨切割(V-Q, Q)的轻量级边的一个端点u
</span><span class='line'>    u = EXTRACT-MIN(Q)
</span><span class='line'>    for each v in G.Adj[u]
</span><span class='line'>    if v in Q and w(u, v) &lt; v.key
</span><span class='line'>        v.PI = u
</span><span class='line'>        v.key = w(u, v)</span></code></pre></td></tr></table></div></figure>


<p>Prim 算法的运行时间取决于最小优先队列Q的实现方式。Prim 算法的总时间代价为O(ElgV), 从渐进意义上说它与Kruskal的运行时间相同。</p>

<h2>Kruskal Prim 算法对比：</h2>

<h4>效率对比：</h4>

<ul>
<li>稠密图： Prim > Kruskal</li>
<li>稀疏图： Kruskal > Prim

<h4>空间对比：</h4>

<p>空间上，要根据数据的情况选择使用那种算法：</p></li>
<li>点少边多时： Kruskal</li>
<li>点多边少时： Prim</li>
</ul>


<p><img src="http://metooit.github.com/pictures/historical_tragedy_thum.gif" title="" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[『python 3 程序开发指南』读书笔记 2]]></title>
    <link href="http://metooit.github.com/blog/2013/02/18/notes-for-learning-python-2/"/>
    <updated>2013-02-18T13:43:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/02/18/notes-for-learning-python-2</id>
    <content type="html"><![CDATA[<ul>
<li>python的序列类型：

<ul>
<li>元组： <code>,</code>

<ul>
<li>不能替换删除其中的数据项。可以用list()转换函数将其转换为列表</li>
<li>元组提供了两种方法： count()返回出现次数， index()返回出现位置。</li>
</ul>
</li>
<li>列表： <code>[]</code>

<ul>
<li>列表是可变的</li>
<li>列表的方法，<code>help(list)</code></li>
<li>任意可迭代的列表元组等都可以使用序列拆分操作符进行拆分<code>*</code></li>
</ul>
</li>
</ul>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>>>> first, *rest = [1, 2, 3, 4, 5, 6]
</span><span class='line'>>>> first, rest
</span><span class='line'>(1, [2, 3, 4, 5, 6])
</span><span class='line'>>>> first, *mid, last = [1, 2, 3, 4, 5, 6]
</span><span class='line'>>>> first, mid, last
</span><span class='line'>(1, [2, 3, 4, 5], 6)</span></code></pre></td></tr></table></div></figure>


<pre><code>    * 下面两段代码等价：
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>>>> words[2:4] = []
</span><span class='line'>>>> del words[2:4]</span></code></pre></td></tr></table></div></figure>


<pre><code>    * 带步距的列表：
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>>>> x = [1,2,3,4,5,6,7,8,9,10]
</span><span class='line'>>>> print(x[1::2])
</span><span class='line'>[2, 4, 6, 8, 10]
</span><span class='line'>>>> x[1::2] = [0] * len(x[1::2])
</span><span class='line'>>>> print(x)
</span><span class='line'>[1, 0, 3, 0, 5, 0, 7, 0, 9, 0]</span></code></pre></td></tr></table></div></figure>


<pre><code>    * 列表内涵：
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>>>> leaps = [ y for y in range(1900, 1940)
</span><span class='line'>... if(y % 4 == 0 and y % 100 != 0 or y % 400 == 0)]
</span><span class='line'>>>> print(leaps)
</span><span class='line'>[1904, 1908, 1912, 1916, 1920, 1924, 1928, 1932, 1936]</span></code></pre></td></tr></table></div></figure>


<ul>
<li>集合： <code>{}</code>

<ul>
<li>集合是可变的</li>
<li>集合的方法：<code>help(set)</code></li>
<li>| &amp; \ ^ 操作</li>
<li>集合内涵：</li>
<li>固定集合</li>
</ul>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>>>> html = {x for x in files if x.lower().endswith((".html", "htm"))}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>映射类型：

<ul>
<li>字典：

<ul>
<li>dict是一种无序的组合数据类型</li>
<li>dict()可作为函数调用</li>
<li>字典的键是独一无二的</li>
<li>字典方法： help(dict)</li>
<li>有序字典：</li>
</ul>
</li>
</ul>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>>>> d = collections.OrderedDict(['z', -4], ('e', 19))</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Talk to my heart]]></title>
    <link href="http://metooit.github.com/blog/2013/02/16/talk-to-my-heart/"/>
    <updated>2013-02-16T22:55:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/02/16/talk-to-my-heart</id>
    <content type="html"><![CDATA[<p>忽然觉得应该和自己好好聊一聊， 主要是有几点要提醒一下自己， 算是自我激励或者自我省查吧。</p>

<ul>
<li>第一点： 大多数时候当你决定做一件事情的时候， 要非常非常认真的去做， 要把这件事情当成一件大事去做</li>
<li>第二点： 学习这件事情其实就是自己的事情， 学会这件事情也不是说说那么简单</li>
<li>第三点： 兴趣是最好的老师， 但猎奇不是兴趣， 尝鲜也不是兴趣， 它们只是你在某个无聊的时候找的一些无用的事情来做罢了</li>
<li>第四点： 学会掌控， 学会把握， 每一个结果都有它的原因， 每一次的成功都不是偶然， 所以你要努力尝试去掌控自己的人生</li>
<li>第五点： 做有用的事情， do something that make sense, make difference. 说不好， 自己体会</li>
<li>第六点： 坚持下去不容易， 保持下去有时候很容易， 但是， 你还年轻除了保持不住的青春年华之外其实你没有什么要保持的， 除了…… （比如自信？）， 所以， 大胆去尝试， 大胆去做吧， 做你想做的事</li>
<li>第七点： 如果不是堕落， 其实做你想做的事还是挺难的， 因为有想法不是那么容易的一件事， 所以先要有想法， 然后付诸实施吧！</li>
<li>第八点： 保持阳光的态度， 相信美好的东西</li>
<li>第九点： 简单、执着</li>
<li>第十点： 放轻松…… 再看一看前九点</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Binary Search Tree]]></title>
    <link href="http://metooit.github.com/blog/2013/02/16/binary-search-tree/"/>
    <updated>2013-02-16T13:04:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/02/16/binary-search-tree</id>
    <content type="html"><![CDATA[<h2>Introduction:</h2>

<p>二叉搜索树上的基本操作所花费的时间与树的高度成正比。对于一个有<code>n</code>个结点的二叉搜索树来说， 基本操作的最坏运行时间为<code>O(lgn)</code>。</p>

<h2>1. 二叉搜索树的概念：</h2>

<ul>
<li>一棵二叉搜索树是以一棵二叉树来组织的</li>
<li>树可以用一个链表的数据结构来表示， 其中的每一个结点就是一个对象</li>
<li>除了<code>key</code> 和 <code>卫星数据</code> 外， 每一个结点还包含了属性 <code>left</code> <code>right</code> 和 <code>p</code>。 如果相应的属性不存在， 那么它的值就是<code>NIL</code>。 根结点是树中唯一一个父指针为NIL的结点。</li>
<li>对于任何节点x， 它的左子树中的关键字最大不能大于x.key, 右子树中的关键字最小不能小于x.key</li>
</ul>


<h2>2. 二叉搜索树上的操作：</h2>

<h3>2.1 如何按序打印二叉树：</h3>

<ul>
<li><p>二叉搜索树的性质决定了我们可以通过简单的<code>递归算法</code>来按顺序打印出二叉树的所有关键字。这种方法称作是<code>中序遍历</code>（inorder tree walk）</p>

<p>** 中序遍历： 输出的子树根的关键字位于其左子树关键字和右子树关键字之间</p>

<p>** 先序遍历： 输出的根的关键字在其左右子树关键字之前</p>

<p>** 后序遍历： 输出的根的关键字在其左右子树关键字之后</p></li>
<li><p>伪代码实现：</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>INORDER-TREE-WALK(x)
</span><span class='line'>    if x != NIL
</span><span class='line'>        INORDER-TREE-WALK(x.left)
</span><span class='line'>        print x.key
</span><span class='line'>        INORDER-TREE-WALK(x.right)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>遍历打印一个有n个结点的二叉搜索树需要耗费O(n)的时间 （证明详见《算法导论（第三版）》）</li>
</ul>


<h3>2.2 查询二叉搜索树：</h3>

<h4>2.2.1查找：</h4>

<ul>
<li>差找是指在一棵二叉搜索数中找到一个具有给定关键字的结点</li>
<li>输入是一个指向树根的指针和一个关键字<code>k</code>, 如果结点存在则返回指向该关键字的指针，否则返回<code>NIL</code></li>
<li>伪代码实现：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>TREE-SEARCH(x, k)
</span><span class='line'>    if x == NIL or k == x.key
</span><span class='line'>        return x
</span><span class='line'>    if x &lt; x.key
</span><span class='line'>        return TREE-SEARCH(x.left, k)
</span><span class='line'>    else
</span><span class='line'>        return TREE-SEARCH(x.right, k)</span></code></pre></td></tr></table></div></figure>


<p><img src="http://metooit.github.com/pictures/BSTree.jpg" title="BSTree" ></p>

<ul>
<li><p>TREE-SEARCH 的运行时间为O(h) (h 是指树的高度)</p></li>
<li><p>我们也可以不用递归， 用<code>while</code>循环来展开</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ITERATIVE-TREE_SEARCH(x, k)
</span><span class='line'>    whiel x != NIL and k != x.key
</span><span class='line'>        if x &lt; x.key
</span><span class='line'>            x = x.left
</span><span class='line'>        else x = x.right
</span><span class='line'>    return x</span></code></pre></td></tr></table></div></figure>


<h4>2.2.2 最大和最小关键字元素：</h4>

<ul>
<li>查找最小关键字的元素：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>TREE-MINIMUM(x)
</span><span class='line'>    while x.left != NIL
</span><span class='line'>        x = x.left
</span><span class='line'>    return x</span></code></pre></td></tr></table></div></figure>


<ul>
<li>查找最大关键字的元素：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>TREE-MAXIMUM(x)
</span><span class='line'>    while x.right != NIL
</span><span class='line'>        x = x.right
</span><span class='line'>    return x</span></code></pre></td></tr></table></div></figure>


<ul>
<li>这两个过程的运行时间为O(h)</li>
</ul>


<h4>2.2.3 后继和前驱：</h4>

<ul>
<li>伪代码的实现过程：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>TREE-SUCCESSOR(x)
</span><span class='line'>    if x.right != NIL
</span><span class='line'>        return TREE-MINIMUM(x.right)
</span><span class='line'>    y = x.p
</span><span class='line'>    while y != NIL and x == y.right
</span><span class='line'>        x = y
</span><span class='line'>        y = y.p</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>两种情况：
<strong> 如果结点x的右子树为非空，那么x的后继恰好是x右子树中的最左的结点
</strong> 如果结点x的右子树非空并且有一个后继y， 那么y就是x的有左孩子的底层祖先， 并且它也是x的一个祖先， 为了找到y， 只需要简单地从x开始沿树而上直到遇到一个其双亲有左孩子的结点</p></li>
<li><p>执行此过程的操作时间同样是O(h)</p></li>
</ul>


<h3>2.3 查找和删除：</h3>

<h4>2.3.1 插入：</h4>

<ul>
<li><p>前提条件： 将一个新值v插入到一棵二叉搜索树T中， 以z作为输入， 其中z.key=v, z.left=NIL, z.right=NIL</p></li>
<li><p>伪代码实现：</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>TREE-INSERT(T, z)
</span><span class='line'>    y = NIL
</span><span class='line'>    x = T.root
</span><span class='line'>    while x != NIL
</span><span class='line'>        y = x
</span><span class='line'>        if z.key &lt; x.key
</span><span class='line'>            x = x.left
</span><span class='line'>        else
</span><span class='line'>            x = x.right
</span><span class='line'>    z.p = y
</span><span class='line'>    if y == NIL
</span><span class='line'>        T.root = z // tree T was empty
</span><span class='line'>    elseif z.key &lt; y.key
</span><span class='line'>        y.left = z
</span><span class='line'>    else
</span><span class='line'>        y.right = z</span></code></pre></td></tr></table></div></figure>


<ul>
<li>TREE-INSERT 的运行时间为O(h)</li>
</ul>


<h4>2.3.2 删除：</h4>

<ul>
<li>一棵二叉搜索树中删除一个结点z的整个策略分为三种基本情况：</li>
<li>如果z没有孩子结点， 那么只是简单地将它删除， 并且修改它的父结点， 用NIL作为孩子来替换z
<img src="http://metooit.github.com/pictures/delete1.png" title="delete1" ></li>
<li>如果z只有一个孩子， 那么将这个孩子提升到树中z的位置上， 并且修改z的父结点， 用z的孩子来替换z
<img src="http://metooit.github.com/pictures/delete2.png" title="delete2" ></li>
<li><p>如果z有两个孩子， 那么找到z的后继y（一定在z的右子树中）， 并且让y占据树中z的位置。 z的原来右子树部分成为y的新右子树， 并且z的左子树成为y的新的左子树。
<img src="http://metooit.github.com/pictures/delete3.png" title="delete3" ></p></li>
<li><p>从一棵二叉搜索树中删除一个结点，如果取指向T和z的指针作为输入：</p></li>
<li>如果z没有左孩子， 那么用其右孩子来替换z， 这个右孩子可以是NIL也可以不是. 当z的右孩子是NIL时， 这种情况就是z只有一个孩子结点的情况。 当z的右孩子非NIL时， 这种情况就是z仅有一个孩子结点的情形， 该孩子是其右孩子。</li>
<li>如果z仅有一个孩子并且为其左孩子时， 那么用左孩子来替换z</li>
<li>否则， z两个孩子都有。 我们要查找z的后继y，这个后继位于z的右子树中并且没有左孩子。 现在需要将y移出原来的位置进行拼接， 并替换树中的z</li>
<li><p>如果y是z的右孩子， 那么用y替换z， 并仅留下y的右孩子</p></li>
<li><p>为了在二叉树中移动子树， 定义TRANSPLANT， 用另一棵子树替换一棵子树并且成为其双亲的孩子结点。</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>TRANSPLANT(T, u, v)
</span><span class='line'>    if u.p == NIL
</span><span class='line'>        T.root = v
</span><span class='line'>    elseif u == u.p.left
</span><span class='line'>        u.p.left = v
</span><span class='line'>    else u.p.right = v
</span><span class='line'>    if v != NIL
</span><span class='line'>        v.p = u.p</span></code></pre></td></tr></table></div></figure>


<ul>
<li>从二叉树中删除结点的过程伪代码：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>TREE-DELETE(T, z)
</span><span class='line'>    if z.left = NIL
</span><span class='line'>        TRANSPLANT(T, z, z.right)
</span><span class='line'>    elseif z.right == NIL
</span><span class='line'>        TRANSPLANT(T, z, z.left)
</span><span class='line'>    else y = TREE-MINIMUM(z.right)
</span><span class='line'>        if y.p != z
</span><span class='line'>            TRANSPLANT(T, y, y.right)
</span><span class='line'>            y.right = z.right
</span><span class='line'>            y.right.p = y
</span><span class='line'>        TRANSPLANT(T, z, y)
</span><span class='line'>        y.left = z.left
</span><span class='line'>        y.left.p = y</span></code></pre></td></tr></table></div></figure>


<ul>
<li>从一棵高度为h的二叉树上删除一个结点的时间代价为O(h)</li>
</ul>


<h3>源代码实现：</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Initialize the binary tree, generate the root node */
</span><span class='line'>Tree_Node* TreeInit(Tree_Node_Key key)
</span><span class='line'>{
</span><span class='line'>    Tree_Node* Start = NULL;
</span><span class='line'>    if ((Start = malloc(sizeof(Tree_Node))) == NULL)
</span><span class='line'>    {
</span><span class='line'>        fprintf(stderr, "Failed to initialize memory\n");
</span><span class='line'>        exit(EXIT_FAILURE);
</span><span class='line'>    }
</span><span class='line'>    Start->key = key;
</span><span class='line'>    Start->left = NULL;
</span><span class='line'>    Start->right = NULL;
</span><span class='line'>    return Start;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/* Insert the given key to the Tree */
</span><span class='line'>Tree_Node* TreeInsert(Tree_Node* Start, Tree_Node_Key key)
</span><span class='line'>{
</span><span class='line'>    if(Start == NULL) {
</span><span class='line'>        return (TreeInit(key));
</span><span class='line'>    }
</span><span class='line'>    else {
</span><span class='line'>        if(Start->key > key)
</span><span class='line'>            Start->left = TreeInsert(Start->left, key);
</span><span class='line'>        else
</span><span class='line'>            Start->right = TreeInsert(Start->right, key);
</span><span class='line'>        return Start;
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>/* Find the node that contains the min key */
</span><span class='line'>Tree_Node* TreeMinimum(Tree_Node* Start)
</span><span class='line'>{
</span><span class='line'>    while(Start->left != NULL)
</span><span class='line'>    {
</span><span class='line'>        Start = Start->left;
</span><span class='line'>    }
</span><span class='line'>    return Start;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/* Find the node that contains the max key */
</span><span class='line'>Tree_Node* TreeMaximum(Tree_Node* Start)
</span><span class='line'>{
</span><span class='line'>    while(Start->right != NULL)
</span><span class='line'>    {
</span><span class='line'>        Start = Start->right;
</span><span class='line'>    }
</span><span class='line'>    return Start;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/* Print the tree in order */
</span><span class='line'>void InorderPrintTree(Tree_Node* Start)
</span><span class='line'>{
</span><span class='line'>    if(Start == NULL)
</span><span class='line'>        return;
</span><span class='line'>    InorderPrintTree(Start->left);
</span><span class='line'>    printf("%d ", Start->key);
</span><span class='line'>    InorderPrintTree(Start->right);
</span><span class='line'>    return;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/* Print the tree in postorder */
</span><span class='line'>void PostorderPrintTree(Tree_Node* Start)
</span><span class='line'>{
</span><span class='line'>    if(Start == NULL)
</span><span class='line'>        return;
</span><span class='line'>    PostorderPrintTree(Start->left);
</span><span class='line'>    PostorderPrintTree(Start->right);
</span><span class='line'>    printf("%d ", Start->key);
</span><span class='line'>    return;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/* Using recurse to free the tree */
</span><span class='line'>void TreeFreeRecurse(Tree_Node* Start)
</span><span class='line'>{
</span><span class='line'>    if(Start == NULL)
</span><span class='line'>        return;
</span><span class='line'>    else {
</span><span class='line'>        TreeFreeRecurse(Start->left);
</span><span class='line'>        TreeFreeRecurse(Start->right);
</span><span class='line'>    }
</span><span class='line'>    free(Start->left);
</span><span class='line'>    free(Start->right);
</span><span class='line'>    return;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/* Free the space of the tree */
</span><span class='line'>void TreeFree(Tree_Node* Start)
</span><span class='line'>{
</span><span class='line'>    TreeFreeRecurse(Start);
</span><span class='line'>    free(Start);
</span><span class='line'>    return;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/* Return the tree size */
</span><span class='line'>int TreeSize(Tree_Node* Start)
</span><span class='line'>{
</span><span class='line'>    if (Start == NULL) return 0;
</span><span class='line'>    else return 1 + TreeSize(Start->left) + TreeSize(Start->right);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/* Return the max depth of the tree */
</span><span class='line'>int TreeMaxDepth(Tree_Node* Start)
</span><span class='line'>{
</span><span class='line'>    if(Start == NULL)
</span><span class='line'>        return 0;
</span><span class='line'>
</span><span class='line'>    if(TreeMaxDepth(Start->left) >= TreeMaxDepth(Start->right))
</span><span class='line'>        return TreeMaxDepth(Start->left) + 1;
</span><span class='line'>    else
</span><span class='line'>        return TreeMaxDepth(Start->right) + 1;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<hr />

<h3>References:</h3>

<ul>
<li><a href="http://www.qmatica.com/DataStructures/Trees/AVL/AVLTree.html">动画演示</a></li>
<li><a href="http://cslibrary.stanford.edu/110/BinaryTrees.html">Binary Trees</a></li>
<li><a href="http://lonelycoder.org/?p=142">A simple introduction to Binary Search Tree</a></li>
<li><a href="http://www.wutianqi.com/?p=2430">《算法导论》学习笔记</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Style]]></title>
    <link href="http://metooit.github.com/blog/2013/02/16/ruby-style-gide/"/>
    <updated>2013-02-16T09:34:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/02/16/ruby-style-gide</id>
    <content type="html"><![CDATA[<blockquote><p>Style is what separates the good from the great.</p></blockquote>

<p><a href="https://github.com/bbatsov/ruby-style-guide">Ruby Style Guide</a></p>

<p><a href="https://github.com/JuanitoFatas/ruby-style-guide/blob/master/README-zhCN.md">简体版本</a></p>

<h2>读书笔记：</h2>

<h3>源代码排版：</h3>

<ul>
<li>使用空格来围绕操作符： 唯一的例外是使用指数操作的时候</li>
<li>把<code>when</code>和<code>case</code>缩排在同一层</li>
<li>在<code>def</code>之间使用空行， 并且把方法分成合乎逻辑的段落</li>
<li>当一个方法呼叫叫的参数过长时， 排列它们</li>
<li>长的常量数字加底线来提高可读性</li>
<li>不要在注解区块和<code>def</code>之间放一个空行</li>
<li>每一行限制在80个字符</li>
<li>避免尾随的空白</li>
</ul>


<h3>语法：</h3>

<ul>
<li><code>def</code>接收参数时使用括号， 没有参数时省略括号</li>
<li>永远不要使用<code>for</code>， 除非你知道为什么， 一般用迭代器来取代</li>
<li>永远不要在多行的<code>if</code>&#8230;<code>unless</code>中使用<code>then</code></li>
<li>偏爱三元操作符 <code>?:</code> 胜于 <code>if/then/else/end</code> 结构</li>
<li>使用表达式来给三元操作符分支， 这意味着三元操作符不能嵌套</li>
<li>布尔表达式使用 &amp;&amp;/||, 控制流程使用 and/or</li>
<li>偏爱 <code>if/unless</code> 修饰符当你有单行的主体， 或者使用控制流程的 <code>and/or</code></li>
<li>否定条件偏爱<code>unless</code> 胜于 <code>if</code></li>
<li>永远不要使用 <code>unless</code> 搭配 <code>else</code></li>
<li>不要使用圆括号围绕 <code>if/unless/while</code> 的条件表达式， 除非这个表达式包含了一个赋值</li>
<li>当你有单行的主体时， 偏爱<code>while/until</code> 修饰符</li>
<li>忽略围绕方法参数的括号</li>
<li>单行区块偏爱<code>{...}</code> 胜于 <code>do...end</code> 多行区块避免使用 <code>{...}</code></li>
<li>避免在不需要控制流程的场合使用 <code>return</code></li>
<li>避免在不需要的情况使用 <code>self</code></li>
<li>避免使用带有局域变量的 <code>shadowing</code> 方法</li>
<li>赋予默认值给方法的参数时需要使用空格来围绕 <code>=</code></li>
<li>使用 <code>||=</code> 来初始化变量， 不要使用该符号初始化布尔变量</li>
<li>避免在方法名和做括号之间放一个空格</li>
<li>如果方法的第一个参数由左括号开始， 那么方法参数应该使用括号</li>
<li>偏好使用<code>lambda</code>新语法</li>
<li>未使用的区块参数用 <code>_</code></li>
</ul>


<h3>命名：</h3>

<ul>
<li>方法与变量使用蛇底式小写</li>
<li>类别与模组使用陀峰方式</li>
<li>其他常数使用蛇底式大写</li>
<li>返回布尔值的方法用 <code>?</code> 结尾</li>
<li>若潜在危险的方法有安全的版本存在时， 应该使用 <code>!</code> 结尾</li>
</ul>


<hr />

<p>（未完待续……）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learn Ruby the hard way]]></title>
    <link href="http://metooit.github.com/blog/2013/02/15/learn-ruby-the-hard-way/"/>
    <updated>2013-02-15T19:23:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/02/15/learn-ruby-the-hard-way</id>
    <content type="html"><![CDATA[<p><a href="http://ruby.learncodethehardway.org/book/">Learn Ruby The Hard Way</a></p>

<p>所谓笨方法学习就是通过不断地实践练习去学习一门新的知识， 但是这应该不算是笨的方法吧。 编程不是有一个一万小时定律吗？ 这应该是学习的正确方法吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning Algorithms : Sort --- Bubble. etc]]></title>
    <link href="http://metooit.github.com/blog/2013/02/15/learning-algorithms-sort-bubble-etc/"/>
    <updated>2013-02-15T16:18:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/02/15/learning-algorithms-sort-bubble-etc</id>
    <content type="html"><![CDATA[<p>显然， 这是一篇水文， 这只是一个患有强迫症的人的需求 ： 必须把自己知道的东西都列在一起才算完整。 我今天就是来完成这一步的， 将我知道的另外几个排序算法罗列在这里， 也许很多算法都没有必要再说但是呢…… 但是……</p>

<hr />

<p>这里有一个<a href="http://caterpillar.onlyfun.net/Gossip/AlgorithmGossip/SelectionInsertionBubble.htm">选择插入冒泡排序的比较</a></p>

<h2>首先冒泡排序：</h2>

<h3>冒泡排序基本性能分析：</h3>

<table>
<thead>
<tr>
<th></th>
<th> 最坏情况时间复杂度    </th>
<th align="left"> 期望时间复杂度   </th>
<th align="left"> 空间复杂度   </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> O(n<sup>2)</sup>                </td>
<td align="left"> O(n<sup>2)</sup>           </td>
<td></td>
</tr>
</tbody>
</table>


<figure class='code'><figcaption><span>bubble-sort      </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="nf">bubbleSort</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">array</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">){</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">temp</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">flag</span><span class="p">;</span>
</span><span class='line'>    <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="k">do</span><span class="p">{</span>
</span><span class='line'>        <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>        <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">length</span><span class="o">-</span><span class="n">i</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&gt;</span><span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]){</span>
</span><span class='line'>                    <span class="n">temp</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span><span class='line'>                    <span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'>                    <span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
</span><span class='line'>                <span class="n">flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">display</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
</span><span class='line'>        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="n">flag</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>*</p>

<p><img src="http://metooit.github.com/pictures/bubble-sort-c.png" title="" ></p>

<p>Python 实现方法：</p>

<figure class='code'><figcaption><span>bubble-sort      </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">bubble</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
</span><span class='line'>        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">val2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
</span><span class='line'>            <span class="k">if</span> <span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
</span><span class='line'>               <span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">lst</span>
</span></code></pre></td></tr></table></div></figure>


<h2>选择排序：</h2>

<h3>选择排序基本性能分析：</h3>

<table>
<thead>
<tr>
<th></th>
<th> 最坏情况时间复杂度    </th>
<th align="left"> 期望时间复杂度   </th>
<th align="left"> 空间复杂度   </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> O(n<sup>2)</sup>                </td>
<td align="left">                  </td>
<td></td>
</tr>
</tbody>
</table>


<figure class='code'><figcaption><span>selectionsort      </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">selectionsort</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)):</span>
</span><span class='line'>        <span class="n">minor</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span><span class='line'>        <span class="n">minor_pos</span> <span class="o">=</span> <span class="n">i</span>
</span><span class='line'>        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)):</span>
</span><span class='line'>            <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">minor</span><span class="p">:</span>
</span><span class='line'>                <span class="n">minor</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
</span><span class='line'>                <span class="n">minor_pos</span> <span class="o">=</span> <span class="n">j</span>
</span><span class='line'>        <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">L</span><span class="p">[</span><span class="n">minor_pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">minor</span><span class="p">,</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">L</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning Algorithms : Sort --- Bucket Sort]]></title>
    <link href="http://metooit.github.com/blog/2013/02/14/learning-algorithms-sort-bucket-sort/"/>
    <updated>2013-02-14T21:03:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/02/14/learning-algorithms-sort-bucket-sort</id>
    <content type="html"><![CDATA[<p><em>桶排序</em> 假设输入数据服从均匀分布， 平均情况下它的时间代价为O(n). 桶排序将[0..1) 的区间划分为了n个大小相同的子区间， 或称为桶(Bucket). 然后将n个输入数分别放到各个桶中。 先对每个桶中的数据进行排序， 然后遍历每个桶， 依照次序把各个桶中的元素列出来即可。</p>

<hr />

<table>
<thead>
<tr>
<th></th>
<th> 最坏情况时间复杂度    </th>
<th align="left"> 期望时间复杂度   </th>
<th align="left"> 空间复杂度   </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> O(n<sup>2)</sup>                </td>
<td align="left"> O(n)             </td>
<td align="left"> O(n)</td>
</tr>
</tbody>
</table>


<ul>
<li>特点：</li>
</ul>


<h3>桶排序伪代码实现：</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>BUCKET-SORT(A)
</span><span class='line'>    n = A.length
</span><span class='line'>    let B[0..n-1] be a new array
</span><span class='line'>    for i = 0 to n - 1
</span><span class='line'>        make B[i] an empty list
</span><span class='line'>    for i = 1 to n
</span><span class='line'>        insert A[i] into list B[nA[i]]
</span><span class='line'>    for i = 0 to n - 1
</span><span class='line'>        sort list B[i] with insertion sort
</span><span class='line'>    concatenate the lists B[0], B[1] ... B[n-1] together in order</span></code></pre></td></tr></table></div></figure>


<p><img src="http://metooit.github.com/pictures/Bucket-Sort.png" title="" ></p>

<h3>桶排序的C语言实现：</h3>

<figure class='code'><figcaption><span>Bucket-Sort      </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/*桶排序的主过程：*/</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">bucketSort</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">array</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">maxElement</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">node</span> <span class="o">**</span><span class="n">bucket</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">**</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">length</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="p">));</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 初始化bucket, 让bucket的每一个节点都为一个带有标号的list:</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>        <span class="n">bucket</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">emptyList</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 将array中的值加入到bucket中的相应位置上：</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 将数组array上的每一个点映射成一个[0..1)上的值， 这里的想</span>
</span><span class='line'>        <span class="c1">// 法是通过让 array[i] 比上数组中的最大值 array[max] + 1 得</span>
</span><span class='line'>        <span class="c1">// 到一个特定范围的值。</span>
</span><span class='line'>        <span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>        <span class="c1">// 然后再将x的值乘上数组的长度, 作为产生桶中的序号（index）</span>
</span><span class='line'>        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">length</span><span class="p">;</span>
</span><span class='line'>        <span class="c1">// 最后将该数组中的对应元素加进桶中， 当然， 加进去的时候</span>
</span><span class='line'>        <span class="c1">// 需要按照标号来加。</span>
</span><span class='line'>        <span class="n">addList</span><span class="p">(</span><span class="n">bucket</span><span class="p">[(</span><span class="kt">int</span><span class="p">)</span><span class="n">x</span><span class="p">],</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 实现桶内链表的各自排序：</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">sortBucket</span><span class="p">(</span><span class="n">bucket</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span class='line'>        <span class="n">p</span> <span class="o">=</span> <span class="n">bucket</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">content</span><span class="p">;</span>
</span><span class='line'>        <span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
</span><span class='line'>            <span class="n">j</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">content</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">freeBucket</span><span class="p">(</span><span class="n">bucket</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>没有想到还挺费劲的啊， 不过结果还是出来了；</p>

<p><img src="http://metooit.github.com/pictures/bucket-sort.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning Algorithms : Sort --- Radix Sort]]></title>
    <link href="http://metooit.github.com/blog/2013/02/14/learning-algorithms-sort-radix-sort/"/>
    <updated>2013-02-14T14:48:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/02/14/learning-algorithms-sort-radix-sort</id>
    <content type="html"><![CDATA[<p><em>基数排序</em>是老式卡片排序机上的算法，为了保证基数排序的正确性， 一位数排序的算法必须是稳定的。</p>

<p><img src="http://metooit.github.com/pictures/radix-sort.jpg" title="" ></p>

<h2>关于排序的稳定性：</h2>

<ul>
<li>排序的稳定性是指： 如果存在具有多个相同排序码的记录， 经过排序后，这些排序码的相对次序仍然保持不变。</li>
</ul>


<p>** 插入排序、 冒泡排序、 归并排序、 桶排序、 基数排序 都是稳定的排序算法</p>

<p>** 不稳定的排序算法: 选择排序、 堆排序、 shell排序、 快速排序都是不稳定的排序</p>

<h2>基数排序的实现过程：</h2>

<!-- more -->


<p><img src="http://metooit.github.com/pictures/radix-sort2.jpg"></p>

<p>用编程来实现：</p>

<figure class='code'><figcaption><span>radix-sort    radix-sort </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// 找到数组中的最大元素</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">maxElement</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">){</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">mov</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">){</span>
</span><span class='line'>            <span class="n">k</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>            <span class="n">mov</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">k</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">radixSort</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">){</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">maxElement</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">length</span><span class="p">);</span>
</span><span class='line'>    <span class="kt">int</span> <span class="o">*</span><span class="n">temp_array</span><span class="p">,</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="n">mult</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/*分配临时数组存储相同大小的元素的个数*/</span>
</span><span class='line'>    <span class="n">temp_array</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</span><span class='line'>    <span class="cm">/*分配数组c用来存储排序后的数组*/</span>
</span><span class='line'>    <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="n">length</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</span><span class='line'>    <span class="n">mult</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/*用计数排序作为稳定的排序算法, 分别对每一位进行排序。*/</span>
</span><span class='line'>    <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">d</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">k</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>            <span class="n">temp_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>            <span class="n">temp_array</span><span class="p">[</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="n">mult</span><span class="p">)]</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">k</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>            <span class="n">temp_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">temp_array</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">){</span>
</span><span class='line'>            <span class="n">result</span><span class="p">[</span><span class="n">temp_array</span><span class="p">[</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">%</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="n">mult</span><span class="p">)]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>            <span class="n">temp_array</span><span class="p">[</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">%</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="n">mult</span><span class="p">)]</span><span class="o">--</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span><span class='line'>            <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">mult</span> <span class="o">*=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>基数排序的结果验证：</h2>

<p><img src="http://metooit.github.com/pictures/radix-sort3.png"></p>

<p><img src="http://metooit.github.com/pictures/radix-sort-final.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning Algorithms : Sort --- Heap Sort]]></title>
    <link href="http://metooit.github.com/blog/2013/02/14/learning-algorithms-sort-heap-sort/"/>
    <updated>2013-02-14T10:52:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/02/14/learning-algorithms-sort-heap-sort</id>
    <content type="html"><![CDATA[<p><em>堆排序</em> 用到了 <em>堆</em> 这种数据结构， 所以我也要再次复习一下堆了。</p>

<hr />

<h2>堆：</h2>

<ul>
<li><code>二叉堆</code>是一个数组， 它可以被看成近似的完全二叉树， 树上的每一个节点对应数组中的一个元素。除了<code>底层</code>之外， 树是完全满的， 从左到右填充。</li>
<li>堆的数组A包含有两个属性： <strong> A.length 表示数组元素的个数， </strong> A.heap_size 表示有多少个堆元素在数组中。 A[1..A.heap-size]存放堆的有效数据。</li>
</ul>


<p>堆中的一个节点<code>i</code>的数据结构：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>PARENT(i)
</span><span class='line'>1   return [i/2]
</span><span class='line'>
</span><span class='line'>LEFT(i)
</span><span class='line'>1   return 2i
</span><span class='line'>
</span><span class='line'>Right(i)
</span><span class='line'>1   return 2i + 1</span></code></pre></td></tr></table></div></figure>


<p><img src="http://metooit.github.com/pictures/heap-i.png" title="heap-i" ></p>

<ul>
<li>二叉堆可以分为两种形式，： 最大堆和最小堆。 <strong> 最大堆的性质 ——> A[PARENT(i)] > A[i] </strong> 最小堆性质相反。</li>
<li>在堆排序算法中， 我们使用的是最大堆， 最小堆通常用来构造优先队列。</li>
<li>堆中一个节点的高度是指该节点到叶结点最长简单路径上的边数。</li>
<li>堆结构上的一些基本操作的运行时间基本上与堆的高度成正比， 时间复杂度为 O(lgn).</li>
<li>堆上的一些基本操作：

<blockquote><p>1 MAX-HEAPIFY: 维护最大堆性质的关键。
2 BUILD-MAX-HEAP: 构造最大堆。
3 HEAPSORT: 原址排序 O(nlgn)
4 MAX-HEAP-INSERT HEAP-EXTRACT-MAX &#8230;</p></blockquote></li>
</ul>


<!-- more -->


<p><img src="http://metooit.github.com/pictures/heapSort_2.jpg" title="" ></p>

<p><img src="http://metooit.github.com/pictures/heapSort_3.jpg"></p>

<p><img src="http://metooit.github.com/pictures/heapSort_4.jpg" title="" ></p>

<h3>维护最大堆的性质：</h3>

<p>前面说过， 维护最大堆性质的关键就是要MAX-HEAPIFY:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>MAX-HEAPIFY(A, i)
</span><span class='line'>    l = LEFT(i)
</span><span class='line'>    r = RIGHT(i)
</span><span class='line'>    if l &lt;= A.heap-size and A[l] > A[i]
</span><span class='line'>        largest = l
</span><span class='line'>    else largest = i
</span><span class='line'>
</span><span class='line'>    if r &lt;= A.heap-size and A[r] > A[largest]
</span><span class='line'>        largest = r
</span><span class='line'>    if largest != i
</span><span class='line'>        exchange A[i] with A[largest]
</span><span class='line'>        MAX-HEAPIFY(A, largest)</span></code></pre></td></tr></table></div></figure>


<p>树高为h的结点执行此过程的时间复杂度为O(h).</p>

<h3>建堆：</h3>

<p>我们可以用自底向上的方法利用MAX-HEAPIFY过程来将一个大小为A.length的数组A[1..n]转化成一个最大堆。子数组A([n/2]+1..n)中的元素都是树的叶结点。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>BUILD-MAX-HEAP(A)
</span><span class='line'>    A.heap-size = A.length
</span><span class='line'>    for i = [A.length/2] downto 1
</span><span class='line'>        MAX-HEAPIFY(A, i)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>建堆的时间复杂度为O(h), 即可以在线性时间内把一个无序数组建成一个最大堆。</li>
</ul>


<h2>堆排序算法：</h2>

<h3>堆排序基本性能分析：</h3>

<table>
<thead>
<tr>
<th></th>
<th> 最坏情况时间复杂度    </th>
<th align="left"> 期望时间复杂度   </th>
<th align="left"> 空间复杂度   </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> O(nlgn)               </td>
<td></td>
<td></td>
</tr>
</tbody>
</table>


<ul>
<li>特点：

<blockquote><ol>
<li>与<em>插入排序</em>相同， 但是与<em>归并排序</em>不同的是， 堆排序同样具有空间原址性 ： 任何时候只需要常数个额外的元素空间存储临时的数据。</li>
</ol>
</blockquote></li>
</ul>


<h3>堆排序伪代码实现：</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>HEAPSORT(A)
</span><span class='line'>    BUILD-MAX-HEAP(A)
</span><span class='line'>    for i = A.length downto 2
</span><span class='line'>        exchange A[1] with A[i]
</span><span class='line'>        A.heap-size -= 1
</span><span class='line'>        MAX-HEAPIFY(A, 1)</span></code></pre></td></tr></table></div></figure>


<h3>堆排序的C语言实现：</h3>

<figure class='code'><figcaption><span>Heapsort      </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="nf">swap</span> <span class="p">(</span> <span class="kt">int</span><span class="o">*</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span> <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">aux</span> <span class="o">=</span> <span class="n">v</span> <span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>  <span class="n">v</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span> <span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span><span class='line'>  <span class="n">v</span> <span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">aux</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm"> * 维护最大堆的性质的 maxHeapify 过程</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">maxHeapify</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">array</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>   <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>   <span class="k">if</span> <span class="p">(</span><span class="n">max</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">array</span><span class="p">[</span><span class="n">max</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">array</span><span class="p">[</span><span class="n">right</span><span class="p">])</span>
</span><span class='line'>         <span class="n">max</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">max</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">array</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">swap</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
</span><span class='line'>        <span class="n">maxHeapify</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
</span><span class='line'>     <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm"> * 建立最大堆的过程</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">buildMaxHeap</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">array</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">size</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
</span><span class='line'>        <span class="n">maxHeapify</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">i</span> <span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm"> * 堆排序的过程</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">heapSort</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">array</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>   <span class="n">buildMaxHeap</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>   <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
</span><span class='line'>   <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>   <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">swap</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">i</span> <span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>      <span class="n">maxHeapify</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">--</span><span class="n">n</span><span class="p">);</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>堆排序的结果验证：</h3>

<p><img src="http://metooit.github.com/pictures/heapsort-result.png" title="heapsort-result" ></p>

<h3>Python 语言的实现过程：</h3>

<figure class='code'><figcaption><span>heapsort      </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">max_heapify</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
</span><span class='line'>    <span class="n">l</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
</span><span class='line'>    <span class="n">r</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="n">l</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">seq</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
</span><span class='line'>        <span class="n">largest</span> <span class="o">=</span> <span class="n">l</span>
</span><span class='line'>    <span class="k">else</span><span class="p">:</span>
</span><span class='line'>        <span class="n">largest</span> <span class="o">=</span> <span class="n">i</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">seq</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">seq</span><span class="p">[</span><span class="n">largest</span><span class="p">]:</span>
</span><span class='line'>        <span class="n">largest</span> <span class="o">=</span> <span class="n">r</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="n">largest</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
</span><span class='line'>        <span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">seq</span><span class="p">[</span><span class="n">largest</span><span class="p">]</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="n">largest</span><span class="p">],</span> <span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span><span class='line'>        <span class="n">max_heapify</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">largest</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">build_heap</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
</span><span class='line'>    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
</span><span class='line'>        <span class="n">max_heapify</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
</span><span class='line'>    <span class="n">build_heap</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
</span><span class='line'>    <span class="n">heap_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">heap_size</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
</span><span class='line'>        <span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">seq</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span><span class='line'>        <span class="n">heap_size</span> <span class="o">=</span> <span class="n">heap_size</span> <span class="o">-</span> <span class="mi">1</span>
</span><span class='line'>        <span class="n">max_heapify</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">heap_size</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">seq</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="http://metooit.github.com/pictures/heapsort-result2.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learn Algorithms : Sort -- Counting Sort]]></title>
    <link href="http://metooit.github.com/blog/2013/02/13/learn-algorithms-sort-counting-sort/"/>
    <updated>2013-02-13T17:58:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/02/13/learn-algorithms-sort-counting-sort</id>
    <content type="html"><![CDATA[<p>下面要说的是一种<code>线性时间</code>的排序 ———— <code>计数排序</code>（Counting Sort）。</p>

<hr />

<p>计数排序假设n个输入元素中的每一个都是在0到k区间内的一个整数， 其中k为某个整数。</p>

<h2>计数排序的基本思想：</h2>

<p>对于每一个输入元素x， 确定小于x的元素的个数。 利用这一信息， 可以直接把该元素放到它在输出数组的位置上了。当几个元素相同时， 需要略做修改。 因为不能把他们放在数组的同一个位置上。</p>

<h2>计数排序的前提条件：</h2>

<p>假设输入的数组为A[1..n], A.length = n。</p>

<h2>计数排序基本性能分析：</h2>

<table>
<thead>
<tr>
<th></th>
<th> 最坏情况时间复杂度    </th>
<th align="left"> 期望时间复杂度   </th>
<th align="left"> 空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> O(k + n)              </td>
<td align="left"> O(k + n)         </td>
<td align="left"> O(n + k)</td>
</tr>
</tbody>
</table>


<ul>
<li>特点：

<blockquote><ol>
<li>我们还需要两个数组，B[1..n]用来存放排序的输出， C[0..k]用来提供临时的存储空间。</li>
<li>常数时间的排序</li>
</ol>
</blockquote></li>
</ul>


<!-- more -->


<h2>计数排序的描述：</h2>

<h2>计数排序伪代码实现：</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>COUNTING-SORT(A, B, k)
</span><span class='line'>1 let C[0..k] be a new array
</span><span class='line'>2 for i = 0 to k
</span><span class='line'>3   C[i] = 0
</span><span class='line'>4 for j = 1 to A.length
</span><span class='line'>5   C[A[j]] = C[A[j]] + 1
</span><span class='line'>6 // C[i] now contains the number of elements equal to i
</span><span class='line'>7 for i = 1 to k
</span><span class='line'>8   C[i] = C[i] + C[i - 1]
</span><span class='line'>9 // C[i] now contains the number of elements less than or equal to i
</span><span class='line'>10for j = A.length downto 1
</span><span class='line'>11  B[C[A[j]]] = A[j]
</span><span class='line'>12  C[A[j]] = C[A[j]] - 1</span></code></pre></td></tr></table></div></figure>


<p><img src="http://metooit.github.com/pictures/counting-sort.jpg" title="COUNTING-SORT" ></p>

<h2>计数排序的C语言实现：</h2>

<figure class='code'><figcaption><span>counting-sort    counting-sort </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="nf">counting_sort</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">arr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">){</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">idx_arr</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">char</span> <span class="o">*</span><span class="n">count_bucket</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">max</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span><span class='line'>          <span class="n">max</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">count_bucket</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">((</span><span class="n">max</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
</span><span class='line'>  <span class="n">max</span> <span class="o">=</span> <span class="n">max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">count_bucket</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">count_bucket</span><span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">idx_arr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">count_bucket</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>          <span class="k">continue</span><span class="p">;</span>
</span><span class='line'>      <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>          <span class="c1">// for the duplicated value</span>
</span><span class='line'>          <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">count_bucket</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>              <span class="o">*</span><span class="p">(</span><span class="n">arr</span><span class="o">+</span><span class="n">idx_arr</span><span class="p">)</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>              <span class="n">idx_arr</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">free</span><span class="p">(</span><span class="n">count_bucket</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>不小心查到一个很好的网站<a href="http://opendatastructures.org/ods-java/11_2_Counting_Sort_Radix_So.html">counting sort and radix sort</a></li>
<li>发现一个更加cool的东西， 可视化的<a href="http://www.cs.usfca.edu/~galles/visualization/CountingSort.html">counting sort</a></li>
</ul>


<p>本来想写一下Python的版本的， 结果搜索到了<a href="http://rosettacode.org/wiki/Sorting_algorithms/Counting_sort">这个</a>, 想死的心都有了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The useage of SCREEN]]></title>
    <link href="http://metooit.github.com/blog/2013/02/13/the-useage-of-screen/"/>
    <updated>2013-02-13T16:23:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/02/13/the-useage-of-screen</id>
    <content type="html"><![CDATA[<p>Linux <code>SCREEN</code> 的用法：</p>

<h1>窗口基本操作：</h1>

<ul>
<li><code>Ctrl + a</code> + <code>c</code>  产生一个新窗口（new window）</li>
<li><code>Ctrl + a</code> + <code>n</code>  下一个窗口（next window）</li>
<li><code>Ctrl + a</code> + <code>p</code>  上一个窗口（previous window）</li>
<li><code>Ctrl + a</code> + <code>"</code>  从列表中选择窗口（choose from the list）</li>
<li><code>Ctrl + a</code> + <code>Ctrl +a</code> 上一个查看过的窗口</li>
<li><code>Ctrl + a</code> + <code>k</code> 移除窗口</li>
<li><code>Ctrl + a</code> + <code>Space</code> 下一个窗口（Next window）</li>
</ul>


<h1>分屏操作：</h1>

<ul>
<li><code>Ctrl + a</code> + <code>%</code> 垂直分割窗口。</li>
<li><code>Ctrl + a</code> + <code>|</code> 水平分割窗口.</li>
<li><code>Ctrl + a</code> + <code>tab</code> 移动到分割后的另一个区域。（同时可以用方向键完成相同的操作）</li>
<li><code>Ctrl + a</code> + <code>:resize</code> 重新确定区域的大小</li>
<li><code>Ctrl + a</code> + <code>:fit</code> 窗口大小适应终端的大小</li>
<li><code>Ctrl + a</code> + <code>:remove</code> 移除区域。</li>
</ul>


<p>今天<code>Emacs</code>快捷键按顺手了忽然间按到了 <code>Ctrl + a</code> + <code>o</code> 居然可以切换窗口内的区域， 不错不错， 记录之～</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learn Algorithms : Sort --- Merge Sort]]></title>
    <link href="http://metooit.github.com/blog/2013/02/13/learn-algorithms-sort-mergesort/"/>
    <updated>2013-02-13T10:34:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/02/13/learn-algorithms-sort-mergesort</id>
    <content type="html"><![CDATA[<p>下面的这个排序算法呢， 是《算法导论》中首先涉及到一种思想而引出来的算法， 所以这里要总结的不止是<em>归并排序</em>这种算法而已， 还要说一下这里的一种思想方法<code>分治法</code>。</p>

<hr />

<h1>分治法：</h1>

<h2>算法的递归性：</h2>

<p>递归性是指为了解决一个给定的问题， 算法一次或多次地调用自身， 以解决紧密相关的若干子问题。</p>

<h2>算法的思想：</h2>

<p>运用递归来解决问题的算法通常典型地遵守<code>分治法</code>的思想： 将原问题分解为几个规模较小的子问题， 然后递归地求解这些子问题， 最后合并这些子问题的解来建立原问题的解。</p>

<h3>分治模式在每一层的递归时都有三个步骤：</h3>

<ul>
<li><h2>分解:</h2>

<p>原问题为若干子问题</p></li>
<li><h2>解决:</h2>

<p>这些子问题， 递归地求解各个子问题。</p></li>
<li><h2>合并:</h2>

<p>这些子问题的解为原问题的解。</p></li>
</ul>


<hr />

<h1>归并排序基本性能分析：</h1>

<table>
<thead>
<tr>
<th></th>
<th> 最坏情况时间复杂度    </th>
<th align="left"> 期望时间复杂度   </th>
<th align="left"> 空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> O(n lgn)              </td>
<td align="left"> O(n lgn)         </td>
<td align="left"> O(n)</td>
</tr>
</tbody>
</table>


<ul>
<li>插入排序的特点：

<blockquote><ol>
<li>对于少量的元素， 它是一个非常有效的算法。</li>
<li>该算法原址排序输入的数： 算法在数组A中重排这些数， 在任何时候， 最多只有常数个数字存储在数组外面。</li>
</ol>
</blockquote></li>
</ul>


<!-- more -->


<h1>归并排序的实现过程：</h1>

<ul>
<li>分解： 将待排序的n个元素的序列分解问n/2的两个子序列。</li>
<li>解决： 使用归并排序递归地排序两个子序列。</li>
<li>合并： 合并两个已排序的子序列以产生结果。</li>
</ul>


<h1>归并排序的前提条件：</h1>

<p>排序数组 A[p..r]。该数组分解后产生<code>A[p..q]</code>和<code>A[q+1, r]</code>两个部分，其中p &lt; q &lt; r</p>

<h1>归并排序的特点：</h1>

<ul>
<li>归并排序的<em>关键</em>是“合并”步骤中将两个已经排序的序列合并的操作。也就是<code>MERGE</code>的过程。该过程需要<code>O(n)</code>的时间。其中 <code>n = r - p + 1</code>.</li>
<li>为了避免在每一个基本步骤中都检查堆是否为空， 我们在每个堆的底部放上一个哨兵， 它含有一个特殊值， 用于简化代码。</li>
</ul>


<h1>归并排序的伪代码实现：</h1>

<p><code>MERGE</code>过程的实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>MERGE(A, p, q, r)
</span><span class='line'>1   n1 = q - p + 1
</span><span class='line'>2   n2 = r - q
</span><span class='line'>3   let L[1..n1 + 1] and R[1..n2 + 1] be new arrays
</span><span class='line'>4   for i = 1 to n1
</span><span class='line'>5       L[i] = A[p + i - 1]
</span><span class='line'>6   for j = 1 to n2
</span><span class='line'>7       R[j] = A[q + j]
</span><span class='line'>8   L[n1 + 1] = nil
</span><span class='line'>9   R[n2 + 1] = nil
</span><span class='line'>10  i = 1
</span><span class='line'>11  j = 1
</span><span class='line'>12  for k = p to r
</span><span class='line'>13      if L[i] &lt; R[j]
</span><span class='line'>14          A[k] = L[i]
</span><span class='line'>15          i = i + 1
</span><span class='line'>16      else A[k] = R[j]
</span><span class='line'>17          j = j + 1</span></code></pre></td></tr></table></div></figure>


<p>归并排序的主程序：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>MERGE_SORT(A, p, r)
</span><span class='line'>1   if p &lt; r
</span><span class='line'>2       q = [(p + r) / 2]
</span><span class='line'>3       MERGE_SORT(A, p, q)
</span><span class='line'>4       MERGE_SORT(A, q+1, r)
</span><span class='line'>5       MERGE(A, p, q, r)</span></code></pre></td></tr></table></div></figure>


<h1>归并排序的C语言实现：</h1>

<p>首先， 实现算法的核心部分：也就是合并数组的过程， 这个过程实现如下：</p>

<figure class='code'><figcaption><span>insertion_sort    insertion_sort </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm"> * method: merge_arrays</span>
</span><span class='line'><span class="cm"> * dercription : 将传入的两个子数组 sub_array_a 和 sub_array_b 合并， 并将结果存入到结果数组 result_array 中。</span>
</span><span class='line'><span class="cm"> * 其中的传入的另外两个参数分别表示两部分数组的大小。</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">merge_arrays</span><span class="p">(</span><span class="kt">int</span> <span class="n">sub_array_a</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">sub_array_b</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">result_array</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">array_a_size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">array_b_size</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
</span><span class='line'>    <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">=</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">array_a_size</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">array_b_size</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="n">sub_array_a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">sub_array_b</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
</span><span class='line'>            <span class="n">result_array</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub_array_a</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
</span><span class='line'>        <span class="k">else</span>
</span><span class='line'>            <span class="n">result_array</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub_array_b</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 两个子数组中谁先被拷贝完就把另外没有拷贝完的数组放到结果数组 result_array 的最后面。</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">array_a_size</span><span class="p">)</span>
</span><span class='line'>        <span class="n">copy_subsequence</span><span class="p">(</span><span class="n">sub_array_b</span><span class="p">,</span> <span class="n">result_array</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">array_b_size</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">array_a_size</span> <span class="o">+</span> <span class="n">array_b_size</span><span class="p">);</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>        <span class="n">copy_subsequence</span><span class="p">(</span><span class="n">sub_array_a</span><span class="p">,</span> <span class="n">result_array</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">array_a_size</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">array_a_size</span> <span class="o">+</span> <span class="n">array_b_size</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>主过程的实现：</p>

<figure class='code'><figcaption><span>MERGE_SORT    MERGE_SORT </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="kt">int</span> <span class="n">result_array</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">half</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="o">*</span><span class="n">sub_array_a</span><span class="p">,</span> <span class="o">*</span><span class="n">sub_array_b</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">half</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">sub_array_a</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">half</span><span class="p">);</span>
</span><span class='line'>        <span class="n">sub_array_b</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">half</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">copy_subsequence</span><span class="p">(</span><span class="n">result_array</span><span class="p">,</span> <span class="n">sub_array_a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">half</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">half</span><span class="p">);</span>
</span><span class='line'>        <span class="n">copy_subsequence</span><span class="p">(</span><span class="n">result_array</span><span class="p">,</span> <span class="n">sub_array_b</span><span class="p">,</span> <span class="n">half</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="n">half</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">merge_sort</span><span class="p">(</span><span class="n">sub_array_a</span><span class="p">,</span> <span class="n">half</span><span class="p">);</span>
</span><span class='line'>        <span class="n">merge_sort</span><span class="p">(</span><span class="n">sub_array_b</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="n">half</span><span class="p">);</span>
</span><span class='line'>        <span class="n">merge_arrays</span><span class="p">(</span><span class="n">sub_array_a</span><span class="p">,</span> <span class="n">sub_array_b</span><span class="p">,</span> <span class="n">result_array</span><span class="p">,</span> <span class="n">half</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="n">half</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">free</span><span class="p">(</span><span class="n">sub_array_a</span><span class="p">);</span>
</span><span class='line'>        <span class="n">free</span><span class="p">(</span><span class="n">sub_array_b</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<hr />

<p>完成后的结果：</p>

<p><img src="http://metooit.github.com/pictures/merge-sort.png" title="merge-sort" ></p>

<hr />

<h1>Python 语言的实现过程：</h1>

<figure class='code'><figcaption><span>MERGE_SORT    Merge </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
</span><span class='line'>    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'>    <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
</span><span class='line'>    <span class="k">while</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">):</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">left</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">[</span><span class="n">m</span><span class="p">]:</span>
</span><span class='line'>            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">left</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
</span><span class='line'>            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class='line'>        <span class="k">else</span><span class="p">:</span>
</span><span class='line'>            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">right</span><span class="p">[</span><span class="n">m</span><span class="p">])</span>
</span><span class='line'>            <span class="n">m</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">result</span> <span class="o">+=</span> <span class="n">left</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span>
</span><span class='line'>    <span class="n">result</span> <span class="o">+=</span> <span class="n">right</span><span class="p">[</span><span class="n">m</span><span class="p">:]</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">result</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
</span><span class='line'>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">seq</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">middle</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
</span><span class='line'>    <span class="n">left</span> <span class="o">=</span> <span class="n">sort</span><span class="p">(</span><span class="n">seq</span><span class="p">[:</span><span class="n">middle</span><span class="p">])</span>
</span><span class='line'>    <span class="n">right</span> <span class="o">=</span> <span class="n">sort</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">middle</span><span class="p">:])</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">merge</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
</span><span class='line'>    <span class="n">seq</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
</span><span class='line'>    <span class="k">print</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
</span><span class='line'>    <span class="n">seq</span> <span class="o">=</span> <span class="n">sort</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
</span><span class='line'>    <span class="k">print</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>结果截图：</h2>

<p><img src="http://metooit.github.com/pictures/merge-sort-py.png" title="MERGE_SORT" ></p>

<p>好吧， 归并排序就告一段落啦。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learn Algorithms : Sort --- Insertion Sort]]></title>
    <link href="http://metooit.github.com/blog/2013/02/13/learn-algorithms-sort-insertion-sort/"/>
    <updated>2013-02-13T09:24:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/02/13/learn-algorithms-sort-insertion-sort</id>
    <content type="html"><![CDATA[<p>今天认真地把《算法导论》上其他的排序算法整理一下， 当然从最开始介绍的 <em>插入排序</em> 开始了。</p>

<hr />

<h3>插入排序基本性能分析：</h3>

<table>
<thead>
<tr>
<th></th>
<th> 最坏情况时间复杂度    </th>
<th align="left"> 期望时间复杂度   </th>
<th align="left"> 空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> O(n<sup>2)</sup>                </td>
<td align="left"> O(n<sup>2)</sup>           </td>
<td align="left"> O(n)</td>
</tr>
</tbody>
</table>


<ul>
<li>插入排序的特点：

<blockquote><ol>
<li>对于少量的元素， 它是一个非常有效的算法。</li>
<li>该算法原址排序输入的数： 算法在数组A中重排这些数， 在任何时候， 最多只有常数个数字存储在数组外面。</li>
</ol>
</blockquote></li>
</ul>


<!-- more -->


<h3>插入排序的伪代码实现：</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>INSERTION-SORT(A)
</span><span class='line'>1   for j = 2 to A.length
</span><span class='line'>2       key = A[j]
</span><span class='line'>3       // Insert A[j] into the  sorted sequence A[1..j-1]
</span><span class='line'>4       i = j - 1
</span><span class='line'>5       while i > 0 and A[i] > key
</span><span class='line'>6           A[i + 1] = A[i]
</span><span class='line'>7           i = i - 1
</span><span class='line'>8       A[i + 1] = key</span></code></pre></td></tr></table></div></figure>


<h3>插入排序的C语言实现：</h3>

<figure class='code'><figcaption><span>insertion_sort    insertion_sort </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="nf">insertion_sort</span><span class="p">(</span><span class="kt">int</span> <span class="n">array</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">store_index</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span><span class="p">(</span><span class="n">store_index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">store_index</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">store_index</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">store_key</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">store_index</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">int</span> <span class="n">sort_index</span> <span class="o">=</span> <span class="n">store_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>        <span class="k">while</span> <span class="p">(</span><span class="n">sort_index</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">array</span><span class="p">[</span><span class="n">sort_index</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">store_key</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">array</span><span class="p">[</span><span class="n">sort_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">sort_index</span><span class="p">];</span>
</span><span class='line'>            <span class="n">sort_index</span> <span class="o">=</span> <span class="n">sort_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">array</span><span class="p">[</span><span class="n">sort_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">store_key</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="http://metooit.github.com/pictures/insertion_sort.png" title="Insertion_sort" ></p>

<hr />

<h3>插入排序的Python实现：</h3>

<figure class='code'><figcaption><span>insertion_sort     insertion_sort </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)):</span>
</span><span class='line'>        <span class="n">item</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</span><span class='line'>        <span class="n">hole</span> <span class="o">=</span> <span class="n">n</span>
</span><span class='line'>        <span class="k">while</span> <span class="n">hole</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">seq</span><span class="p">[</span><span class="n">hole</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">item</span><span class="p">:</span>
</span><span class='line'>            <span class="n">seq</span><span class="p">[</span><span class="n">hole</span><span class="p">]</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="n">hole</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
</span><span class='line'>            <span class="n">hole</span> <span class="o">=</span> <span class="n">hole</span> <span class="o">-</span> <span class="mi">1</span>
</span><span class='line'>        <span class="n">seq</span><span class="p">[</span><span class="n">hole</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">seq</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="http://metooit.github.com/pictures/insertion_sort2.png" title="insertion_sort2" ></p>

<ul>
<li>后记： 虽然这些东西的实现过程相对简单， 文章也没有什么分量， 但是将这些点滴总结在一起也是一个学习的过程吧， 所以要坚持下去～～</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learn Algorithms : Sort --- Quick Sort]]></title>
    <link href="http://metooit.github.com/blog/2013/02/11/learn-algorithms-sort-quick-sort/"/>
    <updated>2013-02-11T09:52:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/02/11/learn-algorithms-sort-quick-sort</id>
    <content type="html"><![CDATA[<p>前面提到过要系统地学习一下算法， 今天就先从一个排序算法开始。<em>快速排序</em></p>

<hr />

<h3>快速排序基本性能分析：</h3>

<table>
<thead>
<tr>
<th></th>
<th> 最坏情况时间复杂度    </th>
<th align="left"> 期望时间复杂度   </th>
<th align="left"> 空间复杂度   </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> O(n<sup>2)</sup>                </td>
<td align="left"> O(nlgn)          </td>
<td align="left"> O(nlgn)      |</td>
</tr>
</tbody>
</table>


<ul>
<li>特点：

<blockquote><ol>
<li>虽然最坏情况的时间复杂度很差， 但是快速排序通常是实际排序中应用最好的选择， 因为它的平均性能比较好。</li>
<li>它能进行<em>原址排序</em>。</li>
<li>快速排序使用了<em>分治思想</em>。</li>
</ol>
</blockquote></li>
</ul>


<!-- more -->


<h3>快速排序的描述：</h3>

<ul>
<li><p>快速排序分为三个部分： 分解==>解决==>合并</p></li>
<li><p>问题的前提： 对一个典型的数组 A[p..r] 进行排序。</p></li>
<li><p>排序过程：</p>

<blockquote><ol>
<li>分解： 将数组 A[p..r] 划分为两个数组 A[p..q-1] 和 A[q+1..r]， 使得 A[p..q-1] 中的每一个元素都小于等于 A[q]， 而 A[q+1..r] 中的每一个元
素都大于A[q].</li>
<li>解决： 递归调用快速排序， 对两个子数组进行排序。</li>
<li>合并： 以为子数组都是原址排序的，  所以不需要合并操作： 数组 A[p..r] 已经有序。</li>
</ol>
</blockquote></li>
</ul>


<h3>快速排序伪代码实现：</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>QUICKSORT(A, p, r)
</span><span class='line'>1 if p &lt; r
</span><span class='line'>2       q = PARTITION(A, p, r)
</span><span class='line'>3       QUICKSORT(A, p, q - 1)
</span><span class='line'>4       QUICKSORT(A, q + 1, r)</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>为了排序一个数组的全部， 初始调用的是 QUICKSORT(A, 1, A.length)。</p></li>
<li><p>算法的关键部分是 <em>PARTITION</em> 过程， 它实现了对子数组 A[p&#8230;r] 的原址重排。</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>PARTITION(A, p, r)
</span><span class='line'>1  x = A[r]
</span><span class='line'>2  i = p - 1
</span><span class='line'>3  for j = p to r - 1
</span><span class='line'>4       do if A[j] &lt;= x
</span><span class='line'>5             then i = i + 1
</span><span class='line'>6                  exchange A[i] with A[j]
</span><span class='line'>7  exchange A[i + 1] with A[r]
</span><span class='line'>8  return i + 1 ></span></code></pre></td></tr></table></div></figure>


<ul>
<li><code>PARTITION</code>过程总是选择一个 x=A[r] 作为主元， 并围绕它来进行子数组的划分 A[p..r]， 随着程序的进行， 数组可能被划分为四个区域。</li>
</ul>


<table>
<thead>
<tr>
<th></th>
<th> 小于x的部分    </th>
<th align="left"> 大于x的部分    </th>
<th align="left"> 无限制      </th>
<th align="left"> 主元x   </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> <code>X  X  X  X</code>   </td>
<td align="left"> <code>X  X  X  X</code>   </td>
<td align="left"> <code>X  X  X</code>   </td>
<td align="left"> <code>X</code></td>
</tr>
<tr>
<td></td>
<td> <code>p--------i</code>   </td>
<td align="left"> <code>----------</code>   </td>
<td align="left"> <code>j------</code>   </td>
<td align="left"> <code>r</code></td>
</tr>
</tbody>
</table>


<blockquote><p>3 ~ 6 行的循环对人以数组下标 <code>k</code>：会按照 <code>k</code> 与 <code>p</code> <code>i</code> <code>j</code> <code>r</code> 的关系将其放在对应的位置。</p></blockquote>

<ul>
<li><p>快速排序算法的正确性证明参见算法导论（第三版） 96页。</p></li>
<li><p>一个例子：</p></li>
</ul>


<p>对<code>2 8 7 1 3 5 6 4</code> 数组进行排序</p>

<p><img src="http://metooit.github.com/pictures/quick-sort-demo.jpg" title="quick-sort-demo" ></p>

<hr />

<h3>快速排序算法的实现：</h3>

<h4>C 语言实现：</h4>

<ul>
<li>第一步： 先要实现算法的核心部分， PARTITION 过程的实现：</li>
</ul>


<figure class='code'><figcaption><span>quick-sort  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">partition</span><span class="p">(</span><span class="kt">int</span> <span class="n">array</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pivot_index</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">pivot_value</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">pivot_index</span><span class="p">];</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">store_index</span> <span class="o">=</span> <span class="n">left</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">pivot_value</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">store_index</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>            <span class="n">swap</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">store_index</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="n">swap</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">store_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">store_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>依照算法导论上的伪代码可以写出上述的代码，该过程主要实现了传入的数组对应标号的分治过程。通过分治过程可以把数组<code>array</code>中从<code>left</code>到<code>right</code>的
元素以<code>pivot_index</code>为标号的元素为基准分成两部分。</p>

<ul>
<li>第二步： 实现QUICKSORT的主过程：</li>
</ul>


<figure class='code'><figcaption><span>quick-sort-2  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="nf">quicksort</span><span class="p">(</span><span class="kt">int</span> <span class="n">array</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">pivot_index</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">pivot_index</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">pivot_index</span><span class="p">);</span>
</span><span class='line'>        <span class="n">quicksort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">pivot_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>        <span class="n">quicksort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pivot_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>同样是依照算法导论上的实现过程， 我们可以实现快速排序的算法， 其中用到了递归调用， 通过递归调用把数组的每一部分排好序。 注意：由于是原址排
序， 我们就不用再分配新的存储空间，直接在原数组上排序即可。</p>

<ul>
<li>第三步： 细节问题：</li>
</ul>


<figure class='code'><figcaption><span>swap  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span> <span class="n">array</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">temp</span><span class="p">;</span>
</span><span class='line'>    <span class="n">temp</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
</span><span class='line'>    <span class="n">array</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">right</span><span class="p">];</span>
</span><span class='line'>    <span class="n">array</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个程序就很简单了， 实现了数组元素的互换。</p>

<p><img src="http://metooit.github.com/pictures/quick-sort-test.png" title="quick-sort-test" ></p>

<h4>Python 语言实现：</h4>

<figure class='code'><figcaption><span>quick-sort-python  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">quicksort</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">seq</span>
</span><span class='line'>    <span class="k">else</span><span class="p">:</span>
</span><span class='line'>        <span class="n">pivot</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span><span class='line'>        <span class="n">left</span> <span class="o">=</span> <span class="n">sort</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">])</span>
</span><span class='line'>        <span class="n">right</span> <span class="o">=</span> <span class="n">sort</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">pivot</span><span class="p">])</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">left</span> <span class="o">+</span> <span class="p">[</span><span class="n">pivot</span><span class="p">]</span> <span class="o">+</span> <span class="n">right</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
</span><span class='line'>    <span class="n">seq</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
</span><span class='line'>    <span class="n">seq</span> <span class="o">=</span> <span class="n">quicksort</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
</span><span class='line'>    <span class="k">print</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="http://metooit.github.com/pictures/quick-sort-python.png" title="quick-sort-python" ></p>

<p>进一步对python版本进行测试：</p>

<p><img src="http://metooit.github.com/pictures/quick-sort-python2.png" title="quick-sort-python2" ></p>

<p>看来还是python 要简洁不少啊！感慨一下～</p>

<h4>Ruby 语言实现：</h4>

<figure class='code'><figcaption><span>quick-sort-ruby    </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">partition</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
</span><span class='line'>  <span class="n">x</span> <span class="o">=</span> <span class="n">array</span><span class="o">[</span><span class="n">right</span><span class="o">]</span>
</span><span class='line'>  <span class="n">i</span> <span class="o">=</span> <span class="n">left</span> <span class="o">-</span> <span class="mi">1</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="n">left</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">right</span> <span class="k">do</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">array</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="k">then</span>
</span><span class='line'>      <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class='line'>      <span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">,</span> <span class="n">array</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">array</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">,</span> <span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">array</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span><span class="p">,</span> <span class="n">array</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">=</span> <span class="n">array</span><span class="o">[</span><span class="n">right</span><span class="o">]</span><span class="p">,</span> <span class="n">array</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
</span><span class='line'>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">quicksort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="k">then</span>
</span><span class='line'>    <span class="n">q</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
</span><span class='line'>    <span class="n">quicksort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">q</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'>    <span class="n">quicksort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>实现过程和C语言的版本基本没有差别， 这里只是熟悉依稀<code>Ruby</code>的语法罢了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Happy New Year]]></title>
    <link href="http://metooit.github.com/blog/2013/02/09/happy-new-year/"/>
    <updated>2013-02-09T23:10:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/02/09/happy-new-year</id>
    <content type="html"><![CDATA[<p>今天是农历新年的三十， 现在就是除夕夜啦～ 祝所有人都新年快乐啊！</p>

<p>o(∩∩)o&#8230;哈哈， 这个年过了对于我们来说是长了一岁， 总是在过年的时候忽然觉得时间过得好快， 真的好快。 不过年的时候根本就不会去想的事情， 忽然在这岁末涌现在脑海里。 2013真的来了！</p>

<p>大年三十儿的晚上， 忽然觉得没有了小时候过年的兴奋， 也说不上觉得特别想要过年， 可能过年对于我来讲就是<code>寒假不会要结束了吧</code>这个问题要开始考虑了，：）</p>

<p>我感觉我的强迫症越来越厉害了， 在今天一天就有以下表现：</p>

<ul>
<li>贴对联的时候要求做到非常之对齐， 不仅是高度距离等因素， 还有对联上粘的胶带， 胶带的长度， 贴上去的位置， 还有不能贴出气泡…… 唉， 贴个对联真是费了好大的劲儿啊:(</li>
<li>祝福短信上， 因为我觉得可能短信群发有点不够诚意， 我决定要个每个人发一条不一样的短信， 所以…… 连续好几个小时的时间里， 我是一边走路、聊天、看春晚……的时间， 都在发短信啊， 而且还要检查看看是不是有重复的啊……</li>
<li>看春晚， 我要被刘谦的魔术折磨疯了， 我真的很想知道是怎么做到的， 所以看完他的魔术， 我立刻回到电脑前面开始查魔术， 但是， 但是 …… 算了， 就让这小子欺骗广大人民吧， 唉～ 我这个不懂<code>艺术</code>的人……</li>
<li>我是真的必须要遵循<code>三十er晚上熬一宿</code>的习俗啊， 真的， 不到十二点我是真的不放心啊， 而且一定要是正好的十二点我才放心……</li>
<li>我刚刚上<code>github</code>， 结果上不去说是维护， 我点进<code>gitstatus</code>里面写了十分钟， 然后我就一直在刷新看看过了几分钟， 我觉得我是有必要看看医生了……</li>
<li>……</li>
</ul>


<p>先写到这里吧， 过年了， Hello 2013！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning Ruby in Process 1]]></title>
    <link href="http://metooit.github.com/blog/2013/02/08/learning-ruby-in-process-1/"/>
    <updated>2013-02-08T19:26:00+08:00</updated>
    <id>http://metooit.github.com/blog/2013/02/08/learning-ruby-in-process-1</id>
    <content type="html"><![CDATA[<ul>
<li>对于一个字符串中每个字元的遍历：（迭代器 -> <code>iterator</code>）</li>
</ul>


<figure class='code'><figcaption><span>iterator1  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="s2">&quot;abc&quot;</span><span class="o">.</span><span class="n">each_byte</span><span class="p">{</span> <span class="o">|</span><span class="n">c</span><span class="o">|</span> <span class="nb">printf</span> <span class="s2">&quot;&lt;%c&gt;&quot;</span><span class="p">,</span> <span class="n">c</span> <span class="p">};</span> <span class="nb">print</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>each_byte是字符串中处理每个字元的迭代器。</p>

<p>如果是用循环语句来实现的话：</p>

<figure class='code'><figcaption><span>iterator2  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">004</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span>
</span><span class='line'><span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">005</span><span class="p">:</span><span class="mi">1</span><span class="o">&gt;</span> <span class="nb">printf</span> <span class="s2">&quot;&lt;%c&gt;&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class='line'><span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">006</span><span class="p">:</span><span class="mi">1</span><span class="o">&gt;</span> <span class="k">end</span><span class="p">;</span> <span class="nb">print</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><code>retry</code>意思是重新开始循环， 而<code>redo</code>意思是当前循环重新做一次迭代。
举例来说：</li>
</ul>


<figure class='code'><figcaption><span>retry  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'><span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">.</span><span class="n">.</span><span class="mi">4</span>
</span><span class='line'>    <span class="nb">print</span> <span class="n">i</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">==</span> <span class="mi">0</span>
</span><span class='line'>        <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'>        <span class="nb">print</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
</span><span class='line'>        <span class="k">retry</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="nb">print</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>再试试换成<code>redo</code>呢？</p>

<!-- more -->


<ul>
<li><p><code>Ruby</code>的方法可以接受参数：与传统的语言一样， 用括号扩起来， 而且在不引起歧义的情况下，可以省略括号。 有一个特别的参数叫做<code>self</code>。</p></li>
<li><p>新建立一个类别的对象 ClassName.new</p></li>
<li><p><code>Ruby</code>中有继承， 可以重写父类的方法， 如果要增强父类中的方法， 而不是完全替换， 可以用<code>super</code>关键字。</p></li>
<li><p><code>Access Control</code>： 1. 在对象外部定义的函数不能直接由对象来调用 2. 在对象内部定义的函数不能直接被外部调用， 可以将函数变成私有的<code>private: 函数名</code>。</p></li>
<li><p>关于module：</p>

<blockquote><p>module 没有实例
module 没有子类别
module 由module&#8230;end定义</p></blockquote></li>
<li><p><code>::</code>算子会向<code>module</code>查询常数的值， 如果不用这个就要 <code>include</code>。</p></li>
<li><p><code>procedure object</code>程序对象：</p></li>
</ul>


<figure class='code'><figcaption><span>procedure  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">033</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="n">quux</span> <span class="o">=</span> <span class="no">Proc</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span>
</span><span class='line'><span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">034</span><span class="p">:</span><span class="mi">1</span><span class="o">*</span> <span class="nb">puts</span> <span class="s2">&quot;QUUXQUUX&quot;</span>
</span><span class='line'><span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">035</span><span class="p">:</span><span class="mi">1</span><span class="o">&gt;</span> <span class="p">}</span>
</span><span class='line'><span class="o">=&gt;</span> <span class="c1">#&lt;Proc:0x9e1eee4@(irb):33&gt;</span>
</span><span class='line'><span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">036</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="n">quux</span><span class="o">.</span><span class="n">call</span>
</span><span class='line'><span class="no">QUUXQUUX</span>
</span><span class='line'><span class="o">=&gt;</span> <span class="kp">nil</span>
</span><span class='line'><span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">037</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="nb">p</span><span class="p">)</span>
</span><span class='line'><span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">03</span><span class="mi">8</span><span class="p">:</span><span class="mi">1</span><span class="o">&gt;</span> <span class="nb">puts</span> <span class="s2">&quot;About to call a procedure&quot;</span>
</span><span class='line'><span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">03</span><span class="mi">9</span><span class="p">:</span><span class="mi">1</span><span class="o">&gt;</span> <span class="nb">p</span><span class="o">.</span><span class="n">call</span>
</span><span class='line'><span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">040</span><span class="p">:</span><span class="mi">1</span><span class="o">&gt;</span> <span class="nb">puts</span> <span class="s2">&quot;Procedure finished&quot;</span>
</span><span class='line'><span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">041</span><span class="p">:</span><span class="mi">1</span><span class="o">&gt;</span> <span class="k">end</span>
</span><span class='line'><span class="o">=&gt;</span> <span class="kp">nil</span>
</span><span class='line'><span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">042</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="n">run</span> <span class="n">quux</span>
</span><span class='line'><span class="no">About</span> <span class="n">to</span> <span class="n">call</span> <span class="n">a</span> <span class="n">procedure</span>
</span><span class='line'><span class="no">QUUXQUUX</span>
</span><span class='line'><span class="no">Procedure</span> <span class="n">finished</span>
</span><span class='line'><span class="o">=&gt;</span> <span class="kp">nil</span><span class="o">*</span>
</span></code></pre></td></tr></table></div></figure>


<p>利用<code>trap</code>方法， 我们可以针对任何系统信号指派不同的应对措施。</p>

<figure class='code'><figcaption><span>trap  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">047</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="n">inthandler</span> <span class="o">=</span> <span class="no">Proc</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">&quot;Press ^C was paused&quot;</span> <span class="p">}</span>
</span><span class='line'><span class="o">=&gt;</span> <span class="c1">#&lt;Proc:0x9c08614@(irb):47&gt;</span>
</span><span class='line'><span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">04</span><span class="mi">8</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="nb">trap</span> <span class="s2">&quot;SIGINT&quot;</span><span class="p">,</span> <span class="n">inthandler</span>
</span><span class='line'><span class="o">=&gt;</span> <span class="c1">#&lt;Proc:0x9c86e24@(irb):44&gt;</span>
</span><span class='line'><span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">04</span><span class="mi">9</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="no">Press</span> <span class="o">^</span><span class="n">C</span> <span class="n">was</span> <span class="n">paused</span>
</span><span class='line'><span class="nb">exit</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>变量：通过识别标识符就能够区别变量。</li>
</ul>


<table>
<thead>
<tr>
<th>符号   </th>
<th align="right">   意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>$      </td>
<td align="right">   全局变量（globla variable）</td>
</tr>
<tr>
<td>@      </td>
<td align="right">   实例变量（instance ariable）</td>
</tr>
<tr>
<td>[az]或_</td>
<td align="right">   局部变量（local variable）</td>
</tr>
<tr>
<td>[AZ]   </td>
<td align="right">   常量</td>
</tr>
</tbody>
</table>


<p>self 和 nil不能被初始化， 赋值。</p>

<p><strong> 慎重使用全局变量， 可能引发不好纠正的错误
</strong> 全局变量的优点是能够追踪。</p>

<figure class='code'><figcaption><span>global_var  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">005</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="nb">trace_var</span> <span class="p">:</span><span class="vg">$x</span><span class="p">,</span> <span class="no">Proc</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">&quot;$x is now </span><span class="si">#{</span><span class="vg">$x</span><span class="si">}</span><span class="s2">&quot;</span> <span class="p">}</span>
</span><span class='line'><span class="o">=&gt;</span> <span class="kp">nil</span>
</span><span class='line'><span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">006</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="vg">$x</span> <span class="o">=</span> <span class="mi">5</span>
</span><span class='line'><span class="vg">$x</span> <span class="n">is</span> <span class="n">now</span> <span class="mi">5</span>
</span><span class='line'><span class="o">=&gt;</span> <span class="mi">5</span>
</span></code></pre></td></tr></table></div></figure>


<p><a href="http://guides.ruby.tw/ruby/globalvars.html">一个特别参数的表格</a></p>

<figure class='code'><figcaption><span>instance_var  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">007</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">InstTest</span>
</span><span class='line'><span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">00</span><span class="mi">8</span><span class="p">:</span><span class="mi">1</span><span class="o">&gt;</span> <span class="k">def</span> <span class="nf">set_foo</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</span><span class='line'><span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">00</span><span class="mi">9</span><span class="p">:</span><span class="mi">2</span><span class="o">&gt;</span> <span class="vi">@foo</span> <span class="o">=</span> <span class="n">n</span>
</span><span class='line'><span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">010</span><span class="p">:</span><span class="mi">2</span><span class="o">&gt;</span> <span class="k">end</span>
</span><span class='line'><span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">011</span><span class="p">:</span><span class="mi">1</span><span class="o">&gt;</span> <span class="k">def</span> <span class="nf">set_bar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</span><span class='line'><span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">012</span><span class="p">:</span><span class="mi">2</span><span class="o">&gt;</span> <span class="vi">@bar</span> <span class="o">=</span> <span class="n">n</span>
</span><span class='line'><span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">013</span><span class="p">:</span><span class="mi">2</span><span class="o">&gt;</span> <span class="k">end</span>
</span><span class='line'><span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">014</span><span class="p">:</span><span class="mi">1</span><span class="o">&gt;</span> <span class="k">end</span>
</span><span class='line'><span class="o">=&gt;</span> <span class="kp">nil</span>
</span><span class='line'><span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">015</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="n">i</span> <span class="o">=</span> <span class="no">InstTest</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'><span class="o">=&gt;</span> <span class="c1">#&lt;InstTest:0x9220ad4&gt;</span>
</span><span class='line'><span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">016</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="n">i</span><span class="o">.</span><span class="n">set_foo</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span><span class='line'><span class="o">=&gt;</span> <span class="mi">2</span>
</span><span class='line'><span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">017</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="n">i</span>
</span><span class='line'><span class="o">=&gt;</span> <span class="c1">#&lt;InstTest:0x9220ad4 @foo=2&gt;</span>
</span><span class='line'><span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">01</span><span class="mi">8</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="n">i</span><span class="o">.</span><span class="n">set_bar</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</span><span class='line'><span class="o">=&gt;</span> <span class="mi">4</span>
</span><span class='line'><span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">01</span><span class="mi">9</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="n">i</span>
</span><span class='line'><span class="o">=&gt;</span> <span class="c1">#&lt;InstTest:0x9220ad4 @foo=2, @bar=4&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote><p>注意： 局部变量在初始化之前并没有nil值。
局部变量作用域： Proc.new {&#8230;} lambda{&#8230;}  loop{&#8230;} def&#8230;end class&#8230;end  module&#8230;end</p></blockquote>

<ul>
<li><p>defined? 是用来检查识别符是否有定义的算子。</p></li>
<li><p><code>rescue</code>救援， <code>fail</code>唤起一个意外， <code>ensure</code>确认。</p></li>
<li><p><code>inspect</code>方法， 传回以合理方式描述对象的字串。to_s 转换为字符串。</p></li>
<li><p><code>initialize</code>方法， 可以接受参数。（有一种弹性初始化的方式，就是传递参数同时赋初值）。</p></li>
<li><p>statement delimiter ： -> <code>;</code>, 跨行用<code>\</code>.</p></li>
<li><p>comment: <code>#</code> Or <code>=begin...=end</code></p></li>
</ul>


<blockquote><p>参考文献：
<a href="http://guides.ruby.tw/ruby/index.html">Ruby使用手册</a></p></blockquote>
]]></content>
  </entry>
  
</feed>
